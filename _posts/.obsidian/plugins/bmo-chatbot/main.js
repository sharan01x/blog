/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};

// src/main.ts
var main_exports = {};
__export(main_exports, {
  DEFAULT_SETTINGS: () => DEFAULT_SETTINGS,
  checkActiveFile: () => checkActiveFile,
  default: () => BMOGPT7
});
module.exports = __toCommonJS(main_exports);
var import_obsidian15 = require("obsidian");

// src/view.ts
var import_obsidian5 = require("obsidian");

// src/utils/ColorConverter.ts
function colorToHex(colorValue) {
  if (colorValue.startsWith("hsl")) {
    const match = colorValue.match(/(\d+(\.\d+)?)%?/g);
    if (match === null || match.length < 3) {
      throw new Error("Invalid HSL value");
    }
    const h = parseInt(match[0]) / 360;
    const s = parseInt(match[1]) / 100;
    const l = parseInt(match[2]) / 100;
    const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
    const p = 2 * l - q;
    const r = hue2rgb(p, q, h + 1 / 3);
    const g = hue2rgb(p, q, h);
    const b = hue2rgb(p, q, h - 1 / 3);
    const toHex = function(c) {
      const hex2 = Math.round(c * 255).toString(16);
      return hex2.length === 1 ? "0" + hex2 : hex2;
    };
    const hex = "#" + toHex(r) + toHex(g) + toHex(b);
    return hex;
  } else if (colorValue.startsWith("rgb")) {
    const sep = colorValue.indexOf(",") > -1 ? "," : " ";
    const rgbArray = colorValue.substr(4).split(")")[0].split(sep);
    let r = (+rgbArray[0]).toString(16), g = (+rgbArray[1]).toString(16), b = (+rgbArray[2]).toString(16);
    if (r.length == 1)
      r = "0" + r;
    if (g.length == 1)
      g = "0" + g;
    if (b.length == 1)
      b = "0" + b;
    return "#" + r + g + b;
  } else {
    return colorValue;
  }
}
function hue2rgb(p, q, t) {
  if (t < 0)
    t += 1;
  if (t > 1)
    t -= 1;
  if (t < 1 / 6)
    return p + (q - p) * 6 * t;
  if (t < 1 / 2)
    return q;
  if (t < 2 / 3)
    return p + (q - p) * (2 / 3 - t) * 6;
  return p;
}

// src/components/FetchModel.ts
var import_obsidian3 = require("obsidian");

// node_modules/openai/version.mjs
var VERSION = "4.6.0";

// node_modules/openai/streaming.mjs
var Stream = class {
  constructor(response, controller) {
    this.response = response;
    this.controller = controller;
    this.decoder = new SSEDecoder();
  }
  async *iterMessages() {
    if (!this.response.body) {
      this.controller.abort();
      throw new Error(`Attempted to iterate over a response with no body`);
    }
    const lineDecoder = new LineDecoder();
    const iter = readableStreamAsyncIterable(this.response.body);
    for await (const chunk of iter) {
      for (const line of lineDecoder.decode(chunk)) {
        const sse = this.decoder.decode(line);
        if (sse)
          yield sse;
      }
    }
    for (const line of lineDecoder.flush()) {
      const sse = this.decoder.decode(line);
      if (sse)
        yield sse;
    }
  }
  async *[Symbol.asyncIterator]() {
    let done = false;
    try {
      for await (const sse of this.iterMessages()) {
        if (done)
          continue;
        if (sse.data.startsWith("[DONE]")) {
          done = true;
          continue;
        }
        if (sse.event === null) {
          try {
            yield JSON.parse(sse.data);
          } catch (e) {
            console.error(`Could not parse message into JSON:`, sse.data);
            console.error(`From chunk:`, sse.raw);
            throw e;
          }
        }
      }
      done = true;
    } catch (e) {
      if (e instanceof Error && e.name === "AbortError")
        return;
      throw e;
    } finally {
      if (!done)
        this.controller.abort();
    }
  }
};
var SSEDecoder = class {
  constructor() {
    this.event = null;
    this.data = [];
    this.chunks = [];
  }
  decode(line) {
    if (line.endsWith("\r")) {
      line = line.substring(0, line.length - 1);
    }
    if (!line) {
      if (!this.event && !this.data.length)
        return null;
      const sse = {
        event: this.event,
        data: this.data.join("\n"),
        raw: this.chunks
      };
      this.event = null;
      this.data = [];
      this.chunks = [];
      return sse;
    }
    this.chunks.push(line);
    if (line.startsWith(":")) {
      return null;
    }
    let [fieldname, _, value] = partition(line, ":");
    if (value.startsWith(" ")) {
      value = value.substring(1);
    }
    if (fieldname === "event") {
      this.event = value;
    } else if (fieldname === "data") {
      this.data.push(value);
    }
    return null;
  }
};
var LineDecoder = class {
  constructor() {
    this.buffer = [];
    this.trailingCR = false;
  }
  decode(chunk) {
    let text = this.decodeText(chunk);
    if (this.trailingCR) {
      text = "\r" + text;
      this.trailingCR = false;
    }
    if (text.endsWith("\r")) {
      this.trailingCR = true;
      text = text.slice(0, -1);
    }
    if (!text) {
      return [];
    }
    const trailingNewline = LineDecoder.NEWLINE_CHARS.has(text[text.length - 1] || "");
    let lines = text.split(LineDecoder.NEWLINE_REGEXP);
    if (lines.length === 1 && !trailingNewline) {
      this.buffer.push(lines[0]);
      return [];
    }
    if (this.buffer.length > 0) {
      lines = [this.buffer.join("") + lines[0], ...lines.slice(1)];
      this.buffer = [];
    }
    if (!trailingNewline) {
      this.buffer = [lines.pop() || ""];
    }
    return lines;
  }
  decodeText(bytes) {
    var _a2;
    if (bytes == null)
      return "";
    if (typeof bytes === "string")
      return bytes;
    if (typeof Buffer !== "undefined") {
      if (bytes instanceof Buffer) {
        return bytes.toString();
      }
      if (bytes instanceof Uint8Array) {
        return Buffer.from(bytes).toString();
      }
      throw new Error(
        `Unexpected: received non-Uint8Array (${bytes.constructor.name}) stream chunk in an environment with a global "Buffer" defined, which this library assumes to be Node. Please report this error.`
      );
    }
    if (typeof TextDecoder !== "undefined") {
      if (bytes instanceof Uint8Array || bytes instanceof ArrayBuffer) {
        (_a2 = this.textDecoder) !== null && _a2 !== void 0 ? _a2 : this.textDecoder = new TextDecoder("utf8");
        return this.textDecoder.decode(bytes);
      }
      throw new Error(
        `Unexpected: received non-Uint8Array/ArrayBuffer (${bytes.constructor.name}) in a web platform. Please report this error.`
      );
    }
    throw new Error(
      `Unexpected: neither Buffer nor TextDecoder are available as globals. Please report this error.`
    );
  }
  flush() {
    if (!this.buffer.length && !this.trailingCR) {
      return [];
    }
    const lines = [this.buffer.join("")];
    this.buffer = [];
    this.trailingCR = false;
    return lines;
  }
};
LineDecoder.NEWLINE_CHARS = /* @__PURE__ */ new Set(["\n", "\r", "\v", "\f", "", "", "", "\x85", "\u2028", "\u2029"]);
LineDecoder.NEWLINE_REGEXP = /\r\n|[\n\r\x0b\x0c\x1c\x1d\x1e\x85\u2028\u2029]/g;
function partition(str, delimiter) {
  const index = str.indexOf(delimiter);
  if (index !== -1) {
    return [str.substring(0, index), delimiter, str.substring(index + delimiter.length)];
  }
  return [str, "", ""];
}
function readableStreamAsyncIterable(stream) {
  if (stream[Symbol.asyncIterator])
    return stream;
  const reader = stream.getReader();
  return {
    async next() {
      try {
        const result = await reader.read();
        if (result === null || result === void 0 ? void 0 : result.done)
          reader.releaseLock();
        return result;
      } catch (e) {
        reader.releaseLock();
        throw e;
      }
    },
    async return() {
      const cancelPromise = reader.cancel();
      reader.releaseLock();
      await cancelPromise;
      return { done: true, value: void 0 };
    },
    [Symbol.asyncIterator]() {
      return this;
    }
  };
}

// node_modules/openai/error.mjs
var error_exports = {};
__export(error_exports, {
  APIConnectionError: () => APIConnectionError,
  APIConnectionTimeoutError: () => APIConnectionTimeoutError,
  APIError: () => APIError,
  APIUserAbortError: () => APIUserAbortError,
  AuthenticationError: () => AuthenticationError,
  BadRequestError: () => BadRequestError,
  ConflictError: () => ConflictError,
  InternalServerError: () => InternalServerError,
  NotFoundError: () => NotFoundError,
  PermissionDeniedError: () => PermissionDeniedError,
  RateLimitError: () => RateLimitError,
  UnprocessableEntityError: () => UnprocessableEntityError
});
var APIError = class extends Error {
  constructor(status, error, message, headers) {
    super(APIError.makeMessage(error, message));
    this.status = status;
    this.headers = headers;
    const data = error;
    this.error = data;
    this.code = data === null || data === void 0 ? void 0 : data["code"];
    this.param = data === null || data === void 0 ? void 0 : data["param"];
    this.type = data === null || data === void 0 ? void 0 : data["type"];
  }
  static makeMessage(error, message) {
    return (error === null || error === void 0 ? void 0 : error.message) ? typeof error.message === "string" ? error.message : JSON.stringify(error.message) : error ? JSON.stringify(error) : message || "Unknown error occurred";
  }
  static generate(status, errorResponse, message, headers) {
    if (!status) {
      return new APIConnectionError({ cause: castToError(errorResponse) });
    }
    const error = errorResponse === null || errorResponse === void 0 ? void 0 : errorResponse["error"];
    if (status === 400) {
      return new BadRequestError(status, error, message, headers);
    }
    if (status === 401) {
      return new AuthenticationError(status, error, message, headers);
    }
    if (status === 403) {
      return new PermissionDeniedError(status, error, message, headers);
    }
    if (status === 404) {
      return new NotFoundError(status, error, message, headers);
    }
    if (status === 409) {
      return new ConflictError(status, error, message, headers);
    }
    if (status === 422) {
      return new UnprocessableEntityError(status, error, message, headers);
    }
    if (status === 429) {
      return new RateLimitError(status, error, message, headers);
    }
    if (status >= 500) {
      return new InternalServerError(status, error, message, headers);
    }
    return new APIError(status, error, message, headers);
  }
};
var APIUserAbortError = class extends APIError {
  constructor({ message } = {}) {
    super(void 0, void 0, message || "Request was aborted.", void 0);
    this.status = void 0;
  }
};
var APIConnectionError = class extends APIError {
  constructor({ message, cause }) {
    super(void 0, void 0, message || "Connection error.", void 0);
    this.status = void 0;
    if (cause)
      this.cause = cause;
  }
};
var APIConnectionTimeoutError = class extends APIConnectionError {
  constructor({ message } = {}) {
    super({ message: message !== null && message !== void 0 ? message : "Request timed out." });
  }
};
var BadRequestError = class extends APIError {
  constructor() {
    super(...arguments);
    this.status = 400;
  }
};
var AuthenticationError = class extends APIError {
  constructor() {
    super(...arguments);
    this.status = 401;
  }
};
var PermissionDeniedError = class extends APIError {
  constructor() {
    super(...arguments);
    this.status = 403;
  }
};
var NotFoundError = class extends APIError {
  constructor() {
    super(...arguments);
    this.status = 404;
  }
};
var ConflictError = class extends APIError {
  constructor() {
    super(...arguments);
    this.status = 409;
  }
};
var UnprocessableEntityError = class extends APIError {
  constructor() {
    super(...arguments);
    this.status = 422;
  }
};
var RateLimitError = class extends APIError {
  constructor() {
    super(...arguments);
    this.status = 429;
  }
};
var InternalServerError = class extends APIError {
};

// node_modules/openai/_shims/agent.mjs
var getDefaultAgent = (url) => {
  return void 0;
};

// node_modules/openai/_shims/fetch.mjs
var _fetch = fetch.bind(void 0);
var isPolyfilled = false;

// node_modules/openai/_shims/form-data.mjs
var _FormData = FormData;
var _File = typeof File !== "undefined" ? File : (
  // Bun doesn't implement File yet, so just make a shim that throws a helpful error message
  class File2 extends Blob {
    constructor() {
      throw new Error(`file uploads aren't supported in this environment yet as 'File' is not defined`);
    }
  }
);

// node_modules/openai/_shims/getMultipartRequestOptions.mjs
async function getMultipartRequestOptions(form, opts) {
  return { ...opts, body: new MultipartBody(form) };
}

// node_modules/openai/_shims/fileFromPath.mjs
async function fileFromPath() {
  throw new Error(
    "The `fileFromPath` function is only supported in Node. See the README for more details: https://www.github.com/openai/openai-node#file-uploads"
  );
}

// node_modules/openai/_shims/node-readable.mjs
function isFsReadStream(value) {
  return false;
}

// node_modules/openai/uploads.mjs
var isResponseLike = (value) => value != null && typeof value === "object" && typeof value.url === "string" && typeof value.blob === "function";
var isFileLike = (value) => value != null && typeof value === "object" && typeof value.name === "string" && typeof value.lastModified === "number" && isBlobLike(value);
var isBlobLike = (value) => value != null && typeof value === "object" && typeof value.size === "number" && typeof value.type === "string" && typeof value.text === "function" && typeof value.slice === "function" && typeof value.arrayBuffer === "function";
var isUploadable = (value) => {
  return isFileLike(value) || isResponseLike(value) || isFsReadStream(value);
};
async function toFile(value, name, options2 = {}) {
  var _a2, _b, _c;
  value = await value;
  if (isResponseLike(value)) {
    const blob = await value.blob();
    name || (name = (_a2 = new URL(value.url).pathname.split(/[\\/]/).pop()) !== null && _a2 !== void 0 ? _a2 : "unknown_file");
    return new _File([blob], name, options2);
  }
  const bits = await getBytes(value);
  name || (name = (_b = getName(value)) !== null && _b !== void 0 ? _b : "unknown_file");
  if (!options2.type) {
    const type = (_c = bits[0]) === null || _c === void 0 ? void 0 : _c.type;
    if (typeof type === "string") {
      options2 = { ...options2, type };
    }
  }
  return new _File(bits, name, options2);
}
async function getBytes(value) {
  var _a2;
  let parts = [];
  if (typeof value === "string" || ArrayBuffer.isView(value) || // includes Uint8Array, Buffer, etc.
  value instanceof ArrayBuffer) {
    parts.push(value);
  } else if (isBlobLike(value)) {
    parts.push(await value.arrayBuffer());
  } else if (isAsyncIterableIterator(value)) {
    for await (const chunk of value) {
      parts.push(chunk);
    }
  } else {
    throw new Error(
      `Unexpected data type: ${typeof value}; constructor: ${(_a2 = value === null || value === void 0 ? void 0 : value.constructor) === null || _a2 === void 0 ? void 0 : _a2.name}; props: ${propsForError(value)}`
    );
  }
  return parts;
}
function propsForError(value) {
  const props = Object.getOwnPropertyNames(value);
  return `[${props.map((p) => `"${p}"`).join(", ")}]`;
}
function getName(value) {
  var _a2;
  return getStringFromMaybeBuffer(value.name) || getStringFromMaybeBuffer(value.filename) || // For fs.ReadStream
  ((_a2 = getStringFromMaybeBuffer(value.path)) === null || _a2 === void 0 ? void 0 : _a2.split(/[\\/]/).pop());
}
var getStringFromMaybeBuffer = (x) => {
  if (typeof x === "string")
    return x;
  if (typeof Buffer !== "undefined" && x instanceof Buffer)
    return String(x);
  return void 0;
};
var isAsyncIterableIterator = (value) => value != null && typeof value === "object" && typeof value[Symbol.asyncIterator] === "function";
var MultipartBody = class {
  constructor(body) {
    this.body = body;
  }
  get [Symbol.toStringTag]() {
    return "MultipartBody";
  }
};
var isMultipartBody = (body) => body && typeof body === "object" && body.body && body[Symbol.toStringTag] === "MultipartBody";
var multipartFormRequestOptions = async (opts) => {
  const form = await createForm(opts.body);
  return getMultipartRequestOptions(form, opts);
};
var createForm = async (body) => {
  const form = new _FormData();
  await Promise.all(Object.entries(body || {}).map(([key, value]) => addFormValue(form, key, value)));
  return form;
};
var addFormValue = async (form, key, value) => {
  if (value === void 0)
    return;
  if (value == null) {
    throw new TypeError(
      `Received null for "${key}"; to pass null in FormData, you must use the string 'null'`
    );
  }
  if (typeof value === "string" || typeof value === "number" || typeof value === "boolean") {
    form.append(key, String(value));
  } else if (isUploadable(value)) {
    const file = await toFile(value);
    form.append(key, file);
  } else if (Array.isArray(value)) {
    await Promise.all(value.map((entry) => addFormValue(form, key + "[]", entry)));
  } else if (typeof value === "object") {
    await Promise.all(
      Object.entries(value).map(([name, prop]) => addFormValue(form, `${key}[${name}]`, prop))
    );
  } else {
    throw new TypeError(
      `Invalid value given to form, expected a string, number, boolean, object, Array, File or Blob but got ${value} instead`
    );
  }
};

// node_modules/openai/core.mjs
var __classPrivateFieldSet = function(receiver, state, value, kind, f) {
  if (kind === "m")
    throw new TypeError("Private method is not writable");
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
};
var __classPrivateFieldGet = function(receiver, state, kind, f) {
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _AbstractPage_client;
var MAX_RETRIES = 2;
async function defaultParseResponse(props) {
  const { response } = props;
  if (props.options.stream) {
    return new Stream(response, props.controller);
  }
  const contentType = response.headers.get("content-type");
  if (contentType === null || contentType === void 0 ? void 0 : contentType.includes("application/json")) {
    const json = await response.json();
    debug("response", response.status, response.url, response.headers, json);
    return json;
  }
  const text = await response.text();
  debug("response", response.status, response.url, response.headers, text);
  return text;
}
var APIPromise = class extends Promise {
  constructor(responsePromise, parseResponse = defaultParseResponse) {
    super((resolve) => {
      resolve(null);
    });
    this.responsePromise = responsePromise;
    this.parseResponse = parseResponse;
  }
  _thenUnwrap(transform) {
    return new APIPromise(this.responsePromise, async (props) => transform(await this.parseResponse(props)));
  }
  /**
   * Gets the raw `Response` instance instead of parsing the response
   * data.
   *
   * If you want to parse the response body but still get the `Response`
   * instance, you can use {@link withResponse()}.
   */
  asResponse() {
    return this.responsePromise.then((p) => p.response);
  }
  /**
   * Gets the parsed response data and the raw `Response` instance.
   *
   * If you just want to get the raw `Response` instance without parsing it,
   * you can use {@link asResponse()}.
   */
  async withResponse() {
    const [data, response] = await Promise.all([this.parse(), this.asResponse()]);
    return { data, response };
  }
  parse() {
    if (!this.parsedPromise) {
      this.parsedPromise = this.responsePromise.then(this.parseResponse);
    }
    return this.parsedPromise;
  }
  then(onfulfilled, onrejected) {
    return this.parse().then(onfulfilled, onrejected);
  }
  catch(onrejected) {
    return this.parse().catch(onrejected);
  }
  finally(onfinally) {
    return this.parse().finally(onfinally);
  }
};
var APIClient = class {
  constructor({
    baseURL,
    maxRetries,
    timeout = 6e5,
    // 10 minutes
    httpAgent,
    fetch: overridenFetch
  }) {
    this.baseURL = baseURL;
    this.maxRetries = validatePositiveInteger(
      "maxRetries",
      maxRetries !== null && maxRetries !== void 0 ? maxRetries : MAX_RETRIES
    );
    this.timeout = validatePositiveInteger("timeout", timeout);
    this.httpAgent = httpAgent;
    this.fetch = overridenFetch !== null && overridenFetch !== void 0 ? overridenFetch : _fetch;
  }
  authHeaders(opts) {
    return {};
  }
  /**
   * Override this to add your own default headers, for example:
   *
   *  {
   *    ...super.defaultHeaders(),
   *    Authorization: 'Bearer 123',
   *  }
   */
  defaultHeaders(opts) {
    return {
      Accept: "application/json",
      "Content-Type": "application/json",
      "User-Agent": this.getUserAgent(),
      ...getPlatformHeaders(),
      ...this.authHeaders(opts)
    };
  }
  /**
   * Override this to add your own headers validation:
   */
  validateHeaders(headers, customHeaders) {
  }
  defaultIdempotencyKey() {
    return `stainless-node-retry-${uuid4()}`;
  }
  get(path, opts) {
    return this.methodRequest("get", path, opts);
  }
  post(path, opts) {
    return this.methodRequest("post", path, opts);
  }
  patch(path, opts) {
    return this.methodRequest("patch", path, opts);
  }
  put(path, opts) {
    return this.methodRequest("put", path, opts);
  }
  delete(path, opts) {
    return this.methodRequest("delete", path, opts);
  }
  methodRequest(method, path, opts) {
    return this.request(Promise.resolve(opts).then((opts2) => ({ method, path, ...opts2 })));
  }
  getAPIList(path, Page2, opts) {
    return this.requestAPIList(Page2, { method: "get", path, ...opts });
  }
  calculateContentLength(body) {
    if (typeof body === "string") {
      if (typeof Buffer !== "undefined") {
        return Buffer.byteLength(body, "utf8").toString();
      }
      if (typeof TextEncoder !== "undefined") {
        const encoder = new TextEncoder();
        const encoded = encoder.encode(body);
        return encoded.length.toString();
      }
    }
    return null;
  }
  buildRequest(options2) {
    var _a2, _b, _c, _d, _e, _f;
    const { method, path, query, headers = {} } = options2;
    const body = isMultipartBody(options2.body) ? options2.body.body : options2.body ? JSON.stringify(options2.body, null, 2) : null;
    const contentLength = this.calculateContentLength(body);
    const url = this.buildURL(path, query);
    if ("timeout" in options2)
      validatePositiveInteger("timeout", options2.timeout);
    const timeout = (_a2 = options2.timeout) !== null && _a2 !== void 0 ? _a2 : this.timeout;
    const httpAgent = (_c = (_b = options2.httpAgent) !== null && _b !== void 0 ? _b : this.httpAgent) !== null && _c !== void 0 ? _c : getDefaultAgent(url);
    const minAgentTimeout = timeout + 1e3;
    if (typeof ((_d = httpAgent === null || httpAgent === void 0 ? void 0 : httpAgent.options) === null || _d === void 0 ? void 0 : _d.timeout) === "number" && minAgentTimeout > ((_e = httpAgent.options.timeout) !== null && _e !== void 0 ? _e : 0)) {
      httpAgent.options.timeout = minAgentTimeout;
    }
    if (this.idempotencyHeader && method !== "get") {
      if (!options2.idempotencyKey)
        options2.idempotencyKey = this.defaultIdempotencyKey();
      headers[this.idempotencyHeader] = options2.idempotencyKey;
    }
    const reqHeaders = {
      ...contentLength && { "Content-Length": contentLength },
      ...this.defaultHeaders(options2),
      ...headers
    };
    if (isMultipartBody(options2.body) && !isPolyfilled) {
      delete reqHeaders["Content-Type"];
    }
    Object.keys(reqHeaders).forEach((key) => reqHeaders[key] === null && delete reqHeaders[key]);
    const req = {
      method,
      ...body && { body },
      headers: reqHeaders,
      ...httpAgent && { agent: httpAgent },
      // @ts-ignore node-fetch uses a custom AbortSignal type that is
      // not compatible with standard web types
      signal: (_f = options2.signal) !== null && _f !== void 0 ? _f : null
    };
    this.validateHeaders(reqHeaders, headers);
    return { req, url, timeout };
  }
  /**
   * Used as a callback for mutating the given `RequestInit` object.
   *
   * This is useful for cases where you want to add certain headers based off of
   * the request properties, e.g. `method` or `url`.
   */
  async prepareRequest(request, { url, options: options2 }) {
  }
  parseHeaders(headers) {
    return !headers ? {} : Symbol.iterator in headers ? Object.fromEntries(Array.from(headers).map((header) => [...header])) : { ...headers };
  }
  makeStatusError(status, error, message, headers) {
    return APIError.generate(status, error, message, headers);
  }
  request(options2, remainingRetries = null) {
    return new APIPromise(this.makeRequest(options2, remainingRetries));
  }
  async makeRequest(optionsInput, retriesRemaining) {
    var _a2, _b, _c;
    const options2 = await optionsInput;
    if (retriesRemaining == null) {
      retriesRemaining = (_a2 = options2.maxRetries) !== null && _a2 !== void 0 ? _a2 : this.maxRetries;
    }
    const { req, url, timeout } = this.buildRequest(options2);
    await this.prepareRequest(req, { url, options: options2 });
    debug("request", url, options2, req.headers);
    if ((_b = options2.signal) === null || _b === void 0 ? void 0 : _b.aborted) {
      throw new APIUserAbortError();
    }
    const controller = new AbortController();
    const response = await this.fetchWithTimeout(url, req, timeout, controller).catch(castToError);
    if (response instanceof Error) {
      if ((_c = options2.signal) === null || _c === void 0 ? void 0 : _c.aborted) {
        throw new APIUserAbortError();
      }
      if (retriesRemaining) {
        return this.retryRequest(options2, retriesRemaining);
      }
      if (response.name === "AbortError") {
        throw new APIConnectionTimeoutError();
      }
      throw new APIConnectionError({ cause: response });
    }
    const responseHeaders = createResponseHeaders(response.headers);
    if (!response.ok) {
      if (retriesRemaining && this.shouldRetry(response)) {
        return this.retryRequest(options2, retriesRemaining, responseHeaders);
      }
      const errText = await response.text().catch(() => "Unknown");
      const errJSON = safeJSON(errText);
      const errMessage = errJSON ? void 0 : errText;
      debug("response", response.status, url, responseHeaders, errMessage);
      const err = this.makeStatusError(response.status, errJSON, errMessage, responseHeaders);
      throw err;
    }
    return { response, options: options2, controller };
  }
  requestAPIList(Page2, options2) {
    const request = this.makeRequest(options2, null);
    return new PagePromise(this, request, Page2);
  }
  buildURL(path, query) {
    const url = isAbsoluteURL(path) ? new URL(path) : new URL(this.baseURL + (this.baseURL.endsWith("/") && path.startsWith("/") ? path.slice(1) : path));
    const defaultQuery = this.defaultQuery();
    if (!isEmptyObj(defaultQuery)) {
      query = { ...defaultQuery, ...query };
    }
    if (query) {
      url.search = this.stringifyQuery(query);
    }
    return url.toString();
  }
  stringifyQuery(query) {
    return Object.entries(query).filter(([_, value]) => typeof value !== "undefined").map(([key, value]) => {
      if (typeof value === "string" || typeof value === "number" || typeof value === "boolean") {
        return `${encodeURIComponent(key)}=${encodeURIComponent(value)}`;
      }
      if (value === null) {
        return `${encodeURIComponent(key)}=`;
      }
      throw new Error(
        `Cannot stringify type ${typeof value}; Expected string, number, boolean, or null. If you need to pass nested query parameters, you can manually encode them, e.g. { query: { 'foo[key1]': value1, 'foo[key2]': value2 } }, and please open a GitHub issue requesting better support for your use case.`
      );
    }).join("&");
  }
  async fetchWithTimeout(url, init, ms, controller) {
    const { signal, ...options2 } = init || {};
    if (signal)
      signal.addEventListener("abort", () => controller.abort());
    const timeout = setTimeout(() => controller.abort(), ms);
    return this.getRequestClient().fetch(url, { signal: controller.signal, ...options2 }).finally(() => {
      clearTimeout(timeout);
    });
  }
  getRequestClient() {
    return { fetch: this.fetch };
  }
  shouldRetry(response) {
    const shouldRetryHeader = response.headers.get("x-should-retry");
    if (shouldRetryHeader === "true")
      return true;
    if (shouldRetryHeader === "false")
      return false;
    if (response.status === 409)
      return true;
    if (response.status === 429)
      return true;
    if (response.status >= 500)
      return true;
    return false;
  }
  async retryRequest(options2, retriesRemaining, responseHeaders) {
    var _a2;
    retriesRemaining -= 1;
    const retryAfter = parseInt(
      (responseHeaders === null || responseHeaders === void 0 ? void 0 : responseHeaders["retry-after"]) || ""
    );
    const maxRetries = (_a2 = options2.maxRetries) !== null && _a2 !== void 0 ? _a2 : this.maxRetries;
    const timeout = this.calculateRetryTimeoutSeconds(retriesRemaining, retryAfter, maxRetries) * 1e3;
    await sleep(timeout);
    return this.makeRequest(options2, retriesRemaining);
  }
  calculateRetryTimeoutSeconds(retriesRemaining, retryAfter, maxRetries) {
    const initialRetryDelay = 0.5;
    const maxRetryDelay = 2;
    if (Number.isInteger(retryAfter) && retryAfter <= 60) {
      return retryAfter;
    }
    const numRetries = maxRetries - retriesRemaining;
    const sleepSeconds = Math.min(initialRetryDelay * Math.pow(numRetries - 1, 2), maxRetryDelay);
    const jitter = Math.random() - 0.5;
    return sleepSeconds + jitter;
  }
  getUserAgent() {
    return `${this.constructor.name}/JS ${VERSION}`;
  }
};
var AbstractPage = class {
  constructor(client, response, body, options2) {
    _AbstractPage_client.set(this, void 0);
    __classPrivateFieldSet(this, _AbstractPage_client, client, "f");
    this.options = options2;
    this.response = response;
    this.body = body;
  }
  hasNextPage() {
    const items = this.getPaginatedItems();
    if (!items.length)
      return false;
    return this.nextPageInfo() != null;
  }
  async getNextPage() {
    const nextInfo = this.nextPageInfo();
    if (!nextInfo) {
      throw new Error(
        "No next page expected; please check `.hasNextPage()` before calling `.getNextPage()`."
      );
    }
    const nextOptions = { ...this.options };
    if ("params" in nextInfo) {
      nextOptions.query = { ...nextOptions.query, ...nextInfo.params };
    } else if ("url" in nextInfo) {
      const params = [...Object.entries(nextOptions.query || {}), ...nextInfo.url.searchParams.entries()];
      for (const [key, value] of params) {
        nextInfo.url.searchParams.set(key, value);
      }
      nextOptions.query = void 0;
      nextOptions.path = nextInfo.url.toString();
    }
    return await __classPrivateFieldGet(this, _AbstractPage_client, "f").requestAPIList(
      this.constructor,
      nextOptions
    );
  }
  async *iterPages() {
    let page = this;
    yield page;
    while (page.hasNextPage()) {
      page = await page.getNextPage();
      yield page;
    }
  }
  async *[(_AbstractPage_client = /* @__PURE__ */ new WeakMap(), Symbol.asyncIterator)]() {
    for await (const page of this.iterPages()) {
      for (const item of page.getPaginatedItems()) {
        yield item;
      }
    }
  }
};
var PagePromise = class extends APIPromise {
  constructor(client, request, Page2) {
    super(
      request,
      async (props) => new Page2(client, props.response, await defaultParseResponse(props), props.options)
    );
  }
  /**
   * Allow auto-paginating iteration on an unawaited list call, eg:
   *
   *    for await (const item of client.items.list()) {
   *      console.log(item)
   *    }
   */
  async *[Symbol.asyncIterator]() {
    const page = await this;
    for await (const item of page) {
      yield item;
    }
  }
};
var createResponseHeaders = (headers) => {
  return new Proxy(
    Object.fromEntries(
      // @ts-ignore
      headers.entries()
    ),
    {
      get(target, name) {
        const key = name.toString();
        return target[key.toLowerCase()] || target[key];
      }
    }
  );
};
var requestOptionsKeys = {
  method: true,
  path: true,
  query: true,
  body: true,
  headers: true,
  maxRetries: true,
  stream: true,
  timeout: true,
  httpAgent: true,
  signal: true,
  idempotencyKey: true
};
var isRequestOptions = (obj) => {
  return typeof obj === "object" && obj !== null && !isEmptyObj(obj) && Object.keys(obj).every((k) => hasOwn(requestOptionsKeys, k));
};
var getPlatformProperties = () => {
  if (typeof Deno !== "undefined" && Deno.build != null) {
    return {
      "X-Stainless-Lang": "js",
      "X-Stainless-Package-Version": VERSION,
      "X-Stainless-OS": normalizePlatform(Deno.build.os),
      "X-Stainless-Arch": normalizeArch(Deno.build.arch),
      "X-Stainless-Runtime": "deno",
      "X-Stainless-Runtime-Version": Deno.version
    };
  }
  if (typeof EdgeRuntime !== "undefined") {
    return {
      "X-Stainless-Lang": "js",
      "X-Stainless-Package-Version": VERSION,
      "X-Stainless-OS": "Unknown",
      "X-Stainless-Arch": `other:${EdgeRuntime}`,
      "X-Stainless-Runtime": "edge",
      "X-Stainless-Runtime-Version": process.version
    };
  }
  if (Object.prototype.toString.call(typeof process !== "undefined" ? process : 0) === "[object process]") {
    return {
      "X-Stainless-Lang": "js",
      "X-Stainless-Package-Version": VERSION,
      "X-Stainless-OS": normalizePlatform(process.platform),
      "X-Stainless-Arch": normalizeArch(process.arch),
      "X-Stainless-Runtime": "node",
      "X-Stainless-Runtime-Version": process.version
    };
  }
  const browserInfo = getBrowserInfo();
  if (browserInfo) {
    return {
      "X-Stainless-Lang": "js",
      "X-Stainless-Package-Version": VERSION,
      "X-Stainless-OS": "Unknown",
      "X-Stainless-Arch": "unknown",
      "X-Stainless-Runtime": `browser:${browserInfo.browser}`,
      "X-Stainless-Runtime-Version": browserInfo.version
    };
  }
  return {
    "X-Stainless-Lang": "js",
    "X-Stainless-Package-Version": VERSION,
    "X-Stainless-OS": "Unknown",
    "X-Stainless-Arch": "unknown",
    "X-Stainless-Runtime": "unknown",
    "X-Stainless-Runtime-Version": "unknown"
  };
};
function getBrowserInfo() {
  if (typeof navigator === "undefined" || !navigator) {
    return null;
  }
  const browserPatterns = [
    { key: "edge", pattern: /Edge(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "ie", pattern: /MSIE(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "ie", pattern: /Trident(?:.*rv\:(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "chrome", pattern: /Chrome(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "firefox", pattern: /Firefox(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "safari", pattern: /(?:Version\W+(\d+)\.(\d+)(?:\.(\d+))?)?(?:\W+Mobile\S*)?\W+Safari/ }
  ];
  for (const { key, pattern } of browserPatterns) {
    const match = pattern.exec(navigator.userAgent);
    if (match) {
      const major = match[1] || 0;
      const minor = match[2] || 0;
      const patch = match[3] || 0;
      return { browser: key, version: `${major}.${minor}.${patch}` };
    }
  }
  return null;
}
var normalizeArch = (arch) => {
  if (arch === "x32")
    return "x32";
  if (arch === "x86_64" || arch === "x64")
    return "x64";
  if (arch === "arm")
    return "arm";
  if (arch === "aarch64" || arch === "arm64")
    return "arm64";
  if (arch)
    return `other:${arch}`;
  return "unknown";
};
var normalizePlatform = (platform) => {
  platform = platform.toLowerCase();
  if (platform.includes("ios"))
    return "iOS";
  if (platform === "android")
    return "Android";
  if (platform === "darwin")
    return "MacOS";
  if (platform === "win32")
    return "Windows";
  if (platform === "freebsd")
    return "FreeBSD";
  if (platform === "openbsd")
    return "OpenBSD";
  if (platform === "linux")
    return "Linux";
  if (platform)
    return `Other:${platform}`;
  return "Unknown";
};
var _platformHeaders;
var getPlatformHeaders = () => {
  return _platformHeaders !== null && _platformHeaders !== void 0 ? _platformHeaders : _platformHeaders = getPlatformProperties();
};
var safeJSON = (text) => {
  try {
    return JSON.parse(text);
  } catch (err) {
    return void 0;
  }
};
var startsWithSchemeRegexp = new RegExp("^(?:[a-z]+:)?//", "i");
var isAbsoluteURL = (url) => {
  return startsWithSchemeRegexp.test(url);
};
var sleep = (ms) => new Promise((resolve) => setTimeout(resolve, ms));
var validatePositiveInteger = (name, n) => {
  if (typeof n !== "number" || !Number.isInteger(n)) {
    throw new Error(`${name} must be an integer`);
  }
  if (n < 0) {
    throw new Error(`${name} must be a positive integer`);
  }
  return n;
};
var castToError = (err) => {
  if (err instanceof Error)
    return err;
  return new Error(err);
};
var readEnv = (env) => {
  var _a2, _b, _c, _d;
  if (typeof process !== "undefined") {
    return (_b = (_a2 = process.env) === null || _a2 === void 0 ? void 0 : _a2[env]) !== null && _b !== void 0 ? _b : void 0;
  }
  if (typeof Deno !== "undefined") {
    return (_d = (_c = Deno.env) === null || _c === void 0 ? void 0 : _c.get) === null || _d === void 0 ? void 0 : _d.call(_c, env);
  }
  return void 0;
};
function isEmptyObj(obj) {
  if (!obj)
    return true;
  for (const _k in obj)
    return false;
  return true;
}
function hasOwn(obj, key) {
  return Object.prototype.hasOwnProperty.call(obj, key);
}
function debug(action, ...args) {
  if (typeof process !== "undefined" && process.env["DEBUG"] === "true") {
    console.log(`OpenAI:DEBUG:${action}`, ...args);
  }
}
var uuid4 = () => {
  return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (c) => {
    const r = Math.random() * 16 | 0;
    const v = c === "x" ? r : r & 3 | 8;
    return v.toString(16);
  });
};
var isRunningInBrowser = () => {
  return (
    // @ts-ignore
    typeof window !== "undefined" && // @ts-ignore
    typeof window.document !== "undefined" && // @ts-ignore
    typeof navigator !== "undefined"
  );
};

// node_modules/openai/pagination.mjs
var Page = class extends AbstractPage {
  constructor(client, response, body, options2) {
    super(client, response, body, options2);
    this.object = body.object;
    this.data = body.data;
  }
  getPaginatedItems() {
    return this.data;
  }
  // @deprecated Please use `nextPageInfo()` instead
  /**
   * This page represents a response that isn't actually paginated at the API level
   * so there will never be any next page params.
   */
  nextPageParams() {
    return null;
  }
  nextPageInfo() {
    return null;
  }
};
var CursorPage = class extends AbstractPage {
  constructor(client, response, body, options2) {
    super(client, response, body, options2);
    this.data = body.data;
  }
  getPaginatedItems() {
    return this.data;
  }
  // @deprecated Please use `nextPageInfo()` instead
  nextPageParams() {
    const info = this.nextPageInfo();
    if (!info)
      return null;
    if ("params" in info)
      return info.params;
    const params = Object.fromEntries(info.url.searchParams);
    if (!Object.keys(params).length)
      return null;
    return params;
  }
  nextPageInfo() {
    var _a2, _b;
    if (!((_a2 = this.data) === null || _a2 === void 0 ? void 0 : _a2.length)) {
      return null;
    }
    const next = (_b = this.data[this.data.length - 1]) === null || _b === void 0 ? void 0 : _b.id;
    if (!next)
      return null;
    return { params: { after: next } };
  }
};

// node_modules/openai/resource.mjs
var APIResource = class {
  constructor(client) {
    this.client = client;
    this.get = client.get.bind(client);
    this.post = client.post.bind(client);
    this.patch = client.patch.bind(client);
    this.put = client.put.bind(client);
    this.delete = client.delete.bind(client);
    this.getAPIList = client.getAPIList.bind(client);
  }
};

// node_modules/openai/resources/audio/transcriptions.mjs
var Transcriptions = class extends APIResource {
  /**
   * Transcribes audio into the input language.
   */
  create(body, options2) {
    return this.post("/audio/transcriptions", multipartFormRequestOptions({ body, ...options2 }));
  }
};
(function(Transcriptions2) {
})(Transcriptions || (Transcriptions = {}));

// node_modules/openai/resources/audio/translations.mjs
var Translations = class extends APIResource {
  /**
   * Translates audio into English.
   */
  create(body, options2) {
    return this.post("/audio/translations", multipartFormRequestOptions({ body, ...options2 }));
  }
};
(function(Translations2) {
})(Translations || (Translations = {}));

// node_modules/openai/resources/audio/audio.mjs
var Audio = class extends APIResource {
  constructor() {
    super(...arguments);
    this.transcriptions = new Transcriptions(this.client);
    this.translations = new Translations(this.client);
  }
};
(function(Audio2) {
  Audio2.Transcriptions = Transcriptions;
  Audio2.Translations = Translations;
})(Audio || (Audio = {}));

// node_modules/openai/resources/chat/completions.mjs
var Completions = class extends APIResource {
  create(body, options2) {
    var _a2;
    return this.post("/chat/completions", {
      body,
      ...options2,
      stream: (_a2 = body.stream) !== null && _a2 !== void 0 ? _a2 : false
    });
  }
};
(function(Completions3) {
})(Completions || (Completions = {}));

// node_modules/openai/resources/chat/chat.mjs
var Chat = class extends APIResource {
  constructor() {
    super(...arguments);
    this.completions = new Completions(this.client);
  }
};
(function(Chat2) {
  Chat2.Completions = Completions;
})(Chat || (Chat = {}));

// node_modules/openai/resources/completions.mjs
var Completions2 = class extends APIResource {
  create(body, options2) {
    var _a2;
    return this.post("/completions", {
      body,
      ...options2,
      stream: (_a2 = body.stream) !== null && _a2 !== void 0 ? _a2 : false
    });
  }
};
(function(Completions3) {
})(Completions2 || (Completions2 = {}));

// node_modules/openai/resources/embeddings.mjs
var Embeddings = class extends APIResource {
  /**
   * Creates an embedding vector representing the input text.
   */
  create(body, options2) {
    return this.post("/embeddings", { body, ...options2 });
  }
};
(function(Embeddings2) {
})(Embeddings || (Embeddings = {}));

// node_modules/openai/resources/edits.mjs
var Edits = class extends APIResource {
  /**
   * Creates a new edit for the provided input, instruction, and parameters.
   *
   * @deprecated The Edits API is deprecated; please use Chat Completions instead.
   *
   * https://openai.com/blog/gpt-4-api-general-availability#deprecation-of-the-edits-api
   */
  create(body, options2) {
    return this.post("/edits", { body, ...options2 });
  }
};
(function(Edits2) {
})(Edits || (Edits = {}));

// node_modules/openai/resources/files.mjs
var Files = class extends APIResource {
  /**
   * Upload a file that contains document(s) to be used across various
   * endpoints/features. Currently, the size of all the files uploaded by one
   * organization can be up to 1 GB. Please contact us if you need to increase the
   * storage limit.
   */
  create(body, options2) {
    return this.post("/files", multipartFormRequestOptions({ body, ...options2 }));
  }
  /**
   * Returns information about a specific file.
   */
  retrieve(fileId, options2) {
    return this.get(`/files/${fileId}`, options2);
  }
  /**
   * Returns a list of files that belong to the user's organization.
   */
  list(options2) {
    return this.getAPIList("/files", FileObjectsPage, options2);
  }
  /**
   * Delete a file.
   */
  del(fileId, options2) {
    return this.delete(`/files/${fileId}`, options2);
  }
  /**
   * Returns the contents of the specified file
   */
  retrieveContent(fileId, options2) {
    return this.get(`/files/${fileId}/content`, {
      ...options2,
      headers: {
        Accept: "application/json",
        ...options2 === null || options2 === void 0 ? void 0 : options2.headers
      }
    });
  }
  /**
   * Waits for the given file to be processed, default timeout is 30 mins.
   */
  async waitForProcessing(id, { pollInterval = 5e3, maxWait = 30 * 60 * 1e3 } = {}) {
    const TERMINAL_STATES = /* @__PURE__ */ new Set(["processed", "error", "deleted"]);
    const start = Date.now();
    let file = await this.retrieve(id);
    while (!file.status || !TERMINAL_STATES.has(file.status)) {
      await sleep(pollInterval);
      file = await this.retrieve(id);
      if (Date.now() - start > maxWait) {
        throw new APIConnectionTimeoutError({
          message: `Giving up on waiting for file ${id} to finish processing after ${maxWait} milliseconds.`
        });
      }
    }
    return file;
  }
};
var FileObjectsPage = class extends Page {
};
(function(Files2) {
})(Files || (Files = {}));

// node_modules/openai/resources/fine-tunes.mjs
var FineTunes = class extends APIResource {
  /**
   * Creates a job that fine-tunes a specified model from a given dataset.
   *
   * Response includes details of the enqueued job including job status and the name
   * of the fine-tuned models once complete.
   *
   * [Learn more about fine-tuning](/docs/guides/legacy-fine-tuning)
   */
  create(body, options2) {
    return this.post("/fine-tunes", { body, ...options2 });
  }
  /**
   * Gets info about the fine-tune job.
   *
   * [Learn more about fine-tuning](/docs/guides/legacy-fine-tuning)
   */
  retrieve(fineTuneId, options2) {
    return this.get(`/fine-tunes/${fineTuneId}`, options2);
  }
  /**
   * List your organization's fine-tuning jobs
   */
  list(options2) {
    return this.getAPIList("/fine-tunes", FineTunesPage, options2);
  }
  /**
   * Immediately cancel a fine-tune job.
   */
  cancel(fineTuneId, options2) {
    return this.post(`/fine-tunes/${fineTuneId}/cancel`, options2);
  }
  listEvents(fineTuneId, query, options2) {
    var _a2;
    return this.get(`/fine-tunes/${fineTuneId}/events`, {
      query,
      timeout: 864e5,
      ...options2,
      stream: (_a2 = query === null || query === void 0 ? void 0 : query.stream) !== null && _a2 !== void 0 ? _a2 : false
    });
  }
};
var FineTunesPage = class extends Page {
};
(function(FineTunes2) {
})(FineTunes || (FineTunes = {}));

// node_modules/openai/resources/fine-tuning/jobs.mjs
var Jobs = class extends APIResource {
  /**
   * Creates a job that fine-tunes a specified model from a given dataset.
   *
   * Response includes details of the enqueued job including job status and the name
   * of the fine-tuned models once complete.
   *
   * [Learn more about fine-tuning](/docs/guides/fine-tuning)
   */
  create(body, options2) {
    return this.post("/fine_tuning/jobs", { body, ...options2 });
  }
  /**
   * Get info about a fine-tuning job.
   *
   * [Learn more about fine-tuning](/docs/guides/fine-tuning)
   */
  retrieve(fineTuningJobId, options2) {
    return this.get(`/fine_tuning/jobs/${fineTuningJobId}`, options2);
  }
  list(query = {}, options2) {
    if (isRequestOptions(query)) {
      return this.list({}, query);
    }
    return this.getAPIList("/fine_tuning/jobs", FineTuningJobsPage, { query, ...options2 });
  }
  /**
   * Immediately cancel a fine-tune job.
   */
  cancel(fineTuningJobId, options2) {
    return this.post(`/fine_tuning/jobs/${fineTuningJobId}/cancel`, options2);
  }
  listEvents(fineTuningJobId, query = {}, options2) {
    if (isRequestOptions(query)) {
      return this.listEvents(fineTuningJobId, {}, query);
    }
    return this.getAPIList(`/fine_tuning/jobs/${fineTuningJobId}/events`, FineTuningJobEventsPage, {
      query,
      ...options2
    });
  }
};
var FineTuningJobsPage = class extends CursorPage {
};
var FineTuningJobEventsPage = class extends CursorPage {
};
(function(Jobs2) {
})(Jobs || (Jobs = {}));

// node_modules/openai/resources/fine-tuning/fine-tuning.mjs
var FineTuning = class extends APIResource {
  constructor() {
    super(...arguments);
    this.jobs = new Jobs(this.client);
  }
};
(function(FineTuning2) {
  FineTuning2.Jobs = Jobs;
  FineTuning2.FineTuningJobsPage = FineTuningJobsPage;
  FineTuning2.FineTuningJobEventsPage = FineTuningJobEventsPage;
})(FineTuning || (FineTuning = {}));

// node_modules/openai/resources/images.mjs
var Images = class extends APIResource {
  /**
   * Creates a variation of a given image.
   */
  createVariation(body, options2) {
    return this.post("/images/variations", multipartFormRequestOptions({ body, ...options2 }));
  }
  /**
   * Creates an edited or extended image given an original image and a prompt.
   */
  edit(body, options2) {
    return this.post("/images/edits", multipartFormRequestOptions({ body, ...options2 }));
  }
  /**
   * Creates an image given a prompt.
   */
  generate(body, options2) {
    return this.post("/images/generations", { body, ...options2 });
  }
};
(function(Images2) {
})(Images || (Images = {}));

// node_modules/openai/resources/models.mjs
var Models = class extends APIResource {
  /**
   * Retrieves a model instance, providing basic information about the model such as
   * the owner and permissioning.
   */
  retrieve(model, options2) {
    return this.get(`/models/${model}`, options2);
  }
  /**
   * Lists the currently available models, and provides basic information about each
   * one such as the owner and availability.
   */
  list(options2) {
    return this.getAPIList("/models", ModelsPage, options2);
  }
  /**
   * Delete a fine-tuned model. You must have the Owner role in your organization to
   * delete a model.
   */
  del(model, options2) {
    return this.delete(`/models/${model}`, options2);
  }
};
var ModelsPage = class extends Page {
};
(function(Models2) {
})(Models || (Models = {}));

// node_modules/openai/resources/moderations.mjs
var Moderations = class extends APIResource {
  /**
   * Classifies if text violates OpenAI's Content Policy
   */
  create(body, options2) {
    return this.post("/moderations", { body, ...options2 });
  }
};
(function(Moderations2) {
})(Moderations || (Moderations = {}));

// node_modules/openai/index.mjs
var _a;
var OpenAI = class extends APIClient {
  /**
   * API Client for interfacing with the OpenAI API.
   *
   * @param {string} [opts.apiKey=process.env['OPENAI_API_KEY']] - The API Key to send to the API.
   * @param {string} [opts.baseURL] - Override the default base URL for the API.
   * @param {number} [opts.timeout=10 minutes] - The maximum amount of time (in milliseconds) the client will wait for a response before timing out.
   * @param {number} [opts.httpAgent] - An HTTP agent used to manage HTTP(s) connections.
   * @param {Core.Fetch} [opts.fetch] - Specify a custom `fetch` function implementation.
   * @param {number} [opts.maxRetries=2] - The maximum number of times the client will retry a request.
   * @param {Core.Headers} opts.defaultHeaders - Default headers to include with every request to the API.
   * @param {Core.DefaultQuery} opts.defaultQuery - Default query parameters to include with every request to the API.
   * @param {boolean} [opts.dangerouslyAllowBrowser=false] - By default, client-side use of this library is not allowed, as it risks exposing your secret API credentials to attackers.
   * @param {string | null} [opts.organization]
   */
  constructor(_b) {
    var _c, _d, _e;
    var {
      apiKey = readEnv("OPENAI_API_KEY"),
      organization = (_c = readEnv("OPENAI_ORG_ID")) !== null && _c !== void 0 ? _c : null,
      ...opts
    } = _b === void 0 ? {} : _b;
    if (apiKey === void 0) {
      throw new Error(
        "The OPENAI_API_KEY environment variable is missing or empty; either provide it, or instantiate the OpenAI client with an apiKey option, like new OpenAI({ apiKey: 'my apiKey' })."
      );
    }
    const options2 = {
      apiKey,
      organization,
      ...opts,
      baseURL: (_d = opts.baseURL) !== null && _d !== void 0 ? _d : `https://api.openai.com/v1`
    };
    if (!options2.dangerouslyAllowBrowser && isRunningInBrowser()) {
      throw new Error(
        "It looks like you're running in a browser-like environment.\n\nThis is disabled by default, as it risks exposing your secret API credentials to attackers.\nIf you understand the risks and have appropriate mitigations in place,\nyou can set the `dangerouslyAllowBrowser` option to `true`, e.g.,\n\nnew OpenAI({ apiKey, dangerouslyAllowBrowser: true });\n\nhttps://help.openai.com/en/articles/5112595-best-practices-for-api-key-safety\n"
      );
    }
    super({
      baseURL: options2.baseURL,
      timeout: (_e = options2.timeout) !== null && _e !== void 0 ? _e : 6e5,
      httpAgent: options2.httpAgent,
      maxRetries: options2.maxRetries,
      fetch: options2.fetch
    });
    this.completions = new Completions2(this);
    this.chat = new Chat(this);
    this.edits = new Edits(this);
    this.embeddings = new Embeddings(this);
    this.files = new Files(this);
    this.images = new Images(this);
    this.audio = new Audio(this);
    this.moderations = new Moderations(this);
    this.models = new Models(this);
    this.fineTuning = new FineTuning(this);
    this.fineTunes = new FineTunes(this);
    this._options = options2;
    this.apiKey = apiKey;
    this.organization = organization;
  }
  defaultQuery() {
    return this._options.defaultQuery;
  }
  defaultHeaders(opts) {
    return {
      ...super.defaultHeaders(opts),
      "OpenAI-Organization": this.organization,
      ...this._options.defaultHeaders
    };
  }
  authHeaders(opts) {
    return { Authorization: `Bearer ${this.apiKey}` };
  }
};
_a = OpenAI;
OpenAI.OpenAI = _a;
OpenAI.APIError = APIError;
OpenAI.APIConnectionError = APIConnectionError;
OpenAI.APIConnectionTimeoutError = APIConnectionTimeoutError;
OpenAI.APIUserAbortError = APIUserAbortError;
OpenAI.NotFoundError = NotFoundError;
OpenAI.ConflictError = ConflictError;
OpenAI.RateLimitError = RateLimitError;
OpenAI.BadRequestError = BadRequestError;
OpenAI.AuthenticationError = AuthenticationError;
OpenAI.InternalServerError = InternalServerError;
OpenAI.PermissionDeniedError = PermissionDeniedError;
OpenAI.UnprocessableEntityError = UnprocessableEntityError;
var {
  APIError: APIError2,
  APIConnectionError: APIConnectionError2,
  APIConnectionTimeoutError: APIConnectionTimeoutError2,
  APIUserAbortError: APIUserAbortError2,
  NotFoundError: NotFoundError2,
  ConflictError: ConflictError2,
  RateLimitError: RateLimitError2,
  BadRequestError: BadRequestError2,
  AuthenticationError: AuthenticationError2,
  InternalServerError: InternalServerError2,
  PermissionDeniedError: PermissionDeniedError2,
  UnprocessableEntityError: UnprocessableEntityError2
} = error_exports;
(function(OpenAI2) {
  OpenAI2.toFile = toFile;
  OpenAI2.fileFromPath = fileFromPath;
  OpenAI2.Page = Page;
  OpenAI2.CursorPage = CursorPage;
  OpenAI2.Completions = Completions2;
  OpenAI2.Chat = Chat;
  OpenAI2.Edits = Edits;
  OpenAI2.Embeddings = Embeddings;
  OpenAI2.Files = Files;
  OpenAI2.FileObjectsPage = FileObjectsPage;
  OpenAI2.Images = Images;
  OpenAI2.Audio = Audio;
  OpenAI2.Moderations = Moderations;
  OpenAI2.Models = Models;
  OpenAI2.ModelsPage = ModelsPage;
  OpenAI2.FineTuning = FineTuning;
  OpenAI2.FineTunes = FineTunes;
  OpenAI2.FineTunesPage = FineTunesPage;
})(OpenAI || (OpenAI = {}));
var openai_default = OpenAI;

// node_modules/marked/lib/marked.esm.js
function getDefaults() {
  return {
    async: false,
    baseUrl: null,
    breaks: false,
    extensions: null,
    gfm: true,
    headerIds: true,
    headerPrefix: "",
    highlight: null,
    hooks: null,
    langPrefix: "language-",
    mangle: true,
    pedantic: false,
    renderer: null,
    sanitize: false,
    sanitizer: null,
    silent: false,
    smartypants: false,
    tokenizer: null,
    walkTokens: null,
    xhtml: false
  };
}
var defaults = getDefaults();
function changeDefaults(newDefaults) {
  defaults = newDefaults;
}
var escapeTest = /[&<>"']/;
var escapeReplace = new RegExp(escapeTest.source, "g");
var escapeTestNoEncode = /[<>"']|&(?!(#\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\w+);)/;
var escapeReplaceNoEncode = new RegExp(escapeTestNoEncode.source, "g");
var escapeReplacements = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#39;"
};
var getEscapeReplacement = (ch) => escapeReplacements[ch];
function escape(html, encode) {
  if (encode) {
    if (escapeTest.test(html)) {
      return html.replace(escapeReplace, getEscapeReplacement);
    }
  } else {
    if (escapeTestNoEncode.test(html)) {
      return html.replace(escapeReplaceNoEncode, getEscapeReplacement);
    }
  }
  return html;
}
var unescapeTest = /&(#(?:\d+)|(?:#x[0-9A-Fa-f]+)|(?:\w+));?/ig;
function unescape(html) {
  return html.replace(unescapeTest, (_, n) => {
    n = n.toLowerCase();
    if (n === "colon")
      return ":";
    if (n.charAt(0) === "#") {
      return n.charAt(1) === "x" ? String.fromCharCode(parseInt(n.substring(2), 16)) : String.fromCharCode(+n.substring(1));
    }
    return "";
  });
}
var caret = /(^|[^\[])\^/g;
function edit(regex, opt) {
  regex = typeof regex === "string" ? regex : regex.source;
  opt = opt || "";
  const obj = {
    replace: (name, val) => {
      val = val.source || val;
      val = val.replace(caret, "$1");
      regex = regex.replace(name, val);
      return obj;
    },
    getRegex: () => {
      return new RegExp(regex, opt);
    }
  };
  return obj;
}
var nonWordAndColonTest = /[^\w:]/g;
var originIndependentUrl = /^$|^[a-z][a-z0-9+.-]*:|^[?#]/i;
function cleanUrl(sanitize, base, href) {
  if (sanitize) {
    let prot;
    try {
      prot = decodeURIComponent(unescape(href)).replace(nonWordAndColonTest, "").toLowerCase();
    } catch (e) {
      return null;
    }
    if (prot.indexOf("javascript:") === 0 || prot.indexOf("vbscript:") === 0 || prot.indexOf("data:") === 0) {
      return null;
    }
  }
  if (base && !originIndependentUrl.test(href)) {
    href = resolveUrl(base, href);
  }
  try {
    href = encodeURI(href).replace(/%25/g, "%");
  } catch (e) {
    return null;
  }
  return href;
}
var baseUrls = {};
var justDomain = /^[^:]+:\/*[^/]*$/;
var protocol = /^([^:]+:)[\s\S]*$/;
var domain = /^([^:]+:\/*[^/]*)[\s\S]*$/;
function resolveUrl(base, href) {
  if (!baseUrls[" " + base]) {
    if (justDomain.test(base)) {
      baseUrls[" " + base] = base + "/";
    } else {
      baseUrls[" " + base] = rtrim(base, "/", true);
    }
  }
  base = baseUrls[" " + base];
  const relativeBase = base.indexOf(":") === -1;
  if (href.substring(0, 2) === "//") {
    if (relativeBase) {
      return href;
    }
    return base.replace(protocol, "$1") + href;
  } else if (href.charAt(0) === "/") {
    if (relativeBase) {
      return href;
    }
    return base.replace(domain, "$1") + href;
  } else {
    return base + href;
  }
}
var noopTest = { exec: function noopTest2() {
} };
function splitCells(tableRow, count) {
  const row = tableRow.replace(/\|/g, (match, offset, str) => {
    let escaped = false, curr = offset;
    while (--curr >= 0 && str[curr] === "\\")
      escaped = !escaped;
    if (escaped) {
      return "|";
    } else {
      return " |";
    }
  }), cells = row.split(/ \|/);
  let i = 0;
  if (!cells[0].trim()) {
    cells.shift();
  }
  if (cells.length > 0 && !cells[cells.length - 1].trim()) {
    cells.pop();
  }
  if (cells.length > count) {
    cells.splice(count);
  } else {
    while (cells.length < count)
      cells.push("");
  }
  for (; i < cells.length; i++) {
    cells[i] = cells[i].trim().replace(/\\\|/g, "|");
  }
  return cells;
}
function rtrim(str, c, invert) {
  const l = str.length;
  if (l === 0) {
    return "";
  }
  let suffLen = 0;
  while (suffLen < l) {
    const currChar = str.charAt(l - suffLen - 1);
    if (currChar === c && !invert) {
      suffLen++;
    } else if (currChar !== c && invert) {
      suffLen++;
    } else {
      break;
    }
  }
  return str.slice(0, l - suffLen);
}
function findClosingBracket(str, b) {
  if (str.indexOf(b[1]) === -1) {
    return -1;
  }
  const l = str.length;
  let level = 0, i = 0;
  for (; i < l; i++) {
    if (str[i] === "\\") {
      i++;
    } else if (str[i] === b[0]) {
      level++;
    } else if (str[i] === b[1]) {
      level--;
      if (level < 0) {
        return i;
      }
    }
  }
  return -1;
}
function checkSanitizeDeprecation(opt) {
  if (opt && opt.sanitize && !opt.silent) {
    console.warn("marked(): sanitize and sanitizer parameters are deprecated since version 0.7.0, should not be used and will be removed in the future. Read more here: https://marked.js.org/#/USING_ADVANCED.md#options");
  }
}
function repeatString(pattern, count) {
  if (count < 1) {
    return "";
  }
  let result = "";
  while (count > 1) {
    if (count & 1) {
      result += pattern;
    }
    count >>= 1;
    pattern += pattern;
  }
  return result + pattern;
}
function outputLink(cap, link, raw, lexer2) {
  const href = link.href;
  const title = link.title ? escape(link.title) : null;
  const text = cap[1].replace(/\\([\[\]])/g, "$1");
  if (cap[0].charAt(0) !== "!") {
    lexer2.state.inLink = true;
    const token = {
      type: "link",
      raw,
      href,
      title,
      text,
      tokens: lexer2.inlineTokens(text)
    };
    lexer2.state.inLink = false;
    return token;
  }
  return {
    type: "image",
    raw,
    href,
    title,
    text: escape(text)
  };
}
function indentCodeCompensation(raw, text) {
  const matchIndentToCode = raw.match(/^(\s+)(?:```)/);
  if (matchIndentToCode === null) {
    return text;
  }
  const indentToCode = matchIndentToCode[1];
  return text.split("\n").map((node) => {
    const matchIndentInNode = node.match(/^\s+/);
    if (matchIndentInNode === null) {
      return node;
    }
    const [indentInNode] = matchIndentInNode;
    if (indentInNode.length >= indentToCode.length) {
      return node.slice(indentToCode.length);
    }
    return node;
  }).join("\n");
}
var Tokenizer = class {
  constructor(options2) {
    this.options = options2 || defaults;
  }
  space(src) {
    const cap = this.rules.block.newline.exec(src);
    if (cap && cap[0].length > 0) {
      return {
        type: "space",
        raw: cap[0]
      };
    }
  }
  code(src) {
    const cap = this.rules.block.code.exec(src);
    if (cap) {
      const text = cap[0].replace(/^ {1,4}/gm, "");
      return {
        type: "code",
        raw: cap[0],
        codeBlockStyle: "indented",
        text: !this.options.pedantic ? rtrim(text, "\n") : text
      };
    }
  }
  fences(src) {
    const cap = this.rules.block.fences.exec(src);
    if (cap) {
      const raw = cap[0];
      const text = indentCodeCompensation(raw, cap[3] || "");
      return {
        type: "code",
        raw,
        lang: cap[2] ? cap[2].trim().replace(this.rules.inline._escapes, "$1") : cap[2],
        text
      };
    }
  }
  heading(src) {
    const cap = this.rules.block.heading.exec(src);
    if (cap) {
      let text = cap[2].trim();
      if (/#$/.test(text)) {
        const trimmed = rtrim(text, "#");
        if (this.options.pedantic) {
          text = trimmed.trim();
        } else if (!trimmed || / $/.test(trimmed)) {
          text = trimmed.trim();
        }
      }
      return {
        type: "heading",
        raw: cap[0],
        depth: cap[1].length,
        text,
        tokens: this.lexer.inline(text)
      };
    }
  }
  hr(src) {
    const cap = this.rules.block.hr.exec(src);
    if (cap) {
      return {
        type: "hr",
        raw: cap[0]
      };
    }
  }
  blockquote(src) {
    const cap = this.rules.block.blockquote.exec(src);
    if (cap) {
      const text = cap[0].replace(/^ *>[ \t]?/gm, "");
      const top = this.lexer.state.top;
      this.lexer.state.top = true;
      const tokens = this.lexer.blockTokens(text);
      this.lexer.state.top = top;
      return {
        type: "blockquote",
        raw: cap[0],
        tokens,
        text
      };
    }
  }
  list(src) {
    let cap = this.rules.block.list.exec(src);
    if (cap) {
      let raw, istask, ischecked, indent, i, blankLine, endsWithBlankLine, line, nextLine, rawLine, itemContents, endEarly;
      let bull = cap[1].trim();
      const isordered = bull.length > 1;
      const list = {
        type: "list",
        raw: "",
        ordered: isordered,
        start: isordered ? +bull.slice(0, -1) : "",
        loose: false,
        items: []
      };
      bull = isordered ? `\\d{1,9}\\${bull.slice(-1)}` : `\\${bull}`;
      if (this.options.pedantic) {
        bull = isordered ? bull : "[*+-]";
      }
      const itemRegex = new RegExp(`^( {0,3}${bull})((?:[	 ][^\\n]*)?(?:\\n|$))`);
      while (src) {
        endEarly = false;
        if (!(cap = itemRegex.exec(src))) {
          break;
        }
        if (this.rules.block.hr.test(src)) {
          break;
        }
        raw = cap[0];
        src = src.substring(raw.length);
        line = cap[2].split("\n", 1)[0].replace(/^\t+/, (t) => " ".repeat(3 * t.length));
        nextLine = src.split("\n", 1)[0];
        if (this.options.pedantic) {
          indent = 2;
          itemContents = line.trimLeft();
        } else {
          indent = cap[2].search(/[^ ]/);
          indent = indent > 4 ? 1 : indent;
          itemContents = line.slice(indent);
          indent += cap[1].length;
        }
        blankLine = false;
        if (!line && /^ *$/.test(nextLine)) {
          raw += nextLine + "\n";
          src = src.substring(nextLine.length + 1);
          endEarly = true;
        }
        if (!endEarly) {
          const nextBulletRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}(?:[*+-]|\\d{1,9}[.)])((?:[ 	][^\\n]*)?(?:\\n|$))`);
          const hrRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}((?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$)`);
          const fencesBeginRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}(?:\`\`\`|~~~)`);
          const headingBeginRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}#`);
          while (src) {
            rawLine = src.split("\n", 1)[0];
            nextLine = rawLine;
            if (this.options.pedantic) {
              nextLine = nextLine.replace(/^ {1,4}(?=( {4})*[^ ])/g, "  ");
            }
            if (fencesBeginRegex.test(nextLine)) {
              break;
            }
            if (headingBeginRegex.test(nextLine)) {
              break;
            }
            if (nextBulletRegex.test(nextLine)) {
              break;
            }
            if (hrRegex.test(src)) {
              break;
            }
            if (nextLine.search(/[^ ]/) >= indent || !nextLine.trim()) {
              itemContents += "\n" + nextLine.slice(indent);
            } else {
              if (blankLine) {
                break;
              }
              if (line.search(/[^ ]/) >= 4) {
                break;
              }
              if (fencesBeginRegex.test(line)) {
                break;
              }
              if (headingBeginRegex.test(line)) {
                break;
              }
              if (hrRegex.test(line)) {
                break;
              }
              itemContents += "\n" + nextLine;
            }
            if (!blankLine && !nextLine.trim()) {
              blankLine = true;
            }
            raw += rawLine + "\n";
            src = src.substring(rawLine.length + 1);
            line = nextLine.slice(indent);
          }
        }
        if (!list.loose) {
          if (endsWithBlankLine) {
            list.loose = true;
          } else if (/\n *\n *$/.test(raw)) {
            endsWithBlankLine = true;
          }
        }
        if (this.options.gfm) {
          istask = /^\[[ xX]\] /.exec(itemContents);
          if (istask) {
            ischecked = istask[0] !== "[ ] ";
            itemContents = itemContents.replace(/^\[[ xX]\] +/, "");
          }
        }
        list.items.push({
          type: "list_item",
          raw,
          task: !!istask,
          checked: ischecked,
          loose: false,
          text: itemContents
        });
        list.raw += raw;
      }
      list.items[list.items.length - 1].raw = raw.trimRight();
      list.items[list.items.length - 1].text = itemContents.trimRight();
      list.raw = list.raw.trimRight();
      const l = list.items.length;
      for (i = 0; i < l; i++) {
        this.lexer.state.top = false;
        list.items[i].tokens = this.lexer.blockTokens(list.items[i].text, []);
        if (!list.loose) {
          const spacers = list.items[i].tokens.filter((t) => t.type === "space");
          const hasMultipleLineBreaks = spacers.length > 0 && spacers.some((t) => /\n.*\n/.test(t.raw));
          list.loose = hasMultipleLineBreaks;
        }
      }
      if (list.loose) {
        for (i = 0; i < l; i++) {
          list.items[i].loose = true;
        }
      }
      return list;
    }
  }
  html(src) {
    const cap = this.rules.block.html.exec(src);
    if (cap) {
      const token = {
        type: "html",
        raw: cap[0],
        pre: !this.options.sanitizer && (cap[1] === "pre" || cap[1] === "script" || cap[1] === "style"),
        text: cap[0]
      };
      if (this.options.sanitize) {
        const text = this.options.sanitizer ? this.options.sanitizer(cap[0]) : escape(cap[0]);
        token.type = "paragraph";
        token.text = text;
        token.tokens = this.lexer.inline(text);
      }
      return token;
    }
  }
  def(src) {
    const cap = this.rules.block.def.exec(src);
    if (cap) {
      const tag = cap[1].toLowerCase().replace(/\s+/g, " ");
      const href = cap[2] ? cap[2].replace(/^<(.*)>$/, "$1").replace(this.rules.inline._escapes, "$1") : "";
      const title = cap[3] ? cap[3].substring(1, cap[3].length - 1).replace(this.rules.inline._escapes, "$1") : cap[3];
      return {
        type: "def",
        tag,
        raw: cap[0],
        href,
        title
      };
    }
  }
  table(src) {
    const cap = this.rules.block.table.exec(src);
    if (cap) {
      const item = {
        type: "table",
        header: splitCells(cap[1]).map((c) => {
          return { text: c };
        }),
        align: cap[2].replace(/^ *|\| *$/g, "").split(/ *\| */),
        rows: cap[3] && cap[3].trim() ? cap[3].replace(/\n[ \t]*$/, "").split("\n") : []
      };
      if (item.header.length === item.align.length) {
        item.raw = cap[0];
        let l = item.align.length;
        let i, j, k, row;
        for (i = 0; i < l; i++) {
          if (/^ *-+: *$/.test(item.align[i])) {
            item.align[i] = "right";
          } else if (/^ *:-+: *$/.test(item.align[i])) {
            item.align[i] = "center";
          } else if (/^ *:-+ *$/.test(item.align[i])) {
            item.align[i] = "left";
          } else {
            item.align[i] = null;
          }
        }
        l = item.rows.length;
        for (i = 0; i < l; i++) {
          item.rows[i] = splitCells(item.rows[i], item.header.length).map((c) => {
            return { text: c };
          });
        }
        l = item.header.length;
        for (j = 0; j < l; j++) {
          item.header[j].tokens = this.lexer.inline(item.header[j].text);
        }
        l = item.rows.length;
        for (j = 0; j < l; j++) {
          row = item.rows[j];
          for (k = 0; k < row.length; k++) {
            row[k].tokens = this.lexer.inline(row[k].text);
          }
        }
        return item;
      }
    }
  }
  lheading(src) {
    const cap = this.rules.block.lheading.exec(src);
    if (cap) {
      return {
        type: "heading",
        raw: cap[0],
        depth: cap[2].charAt(0) === "=" ? 1 : 2,
        text: cap[1],
        tokens: this.lexer.inline(cap[1])
      };
    }
  }
  paragraph(src) {
    const cap = this.rules.block.paragraph.exec(src);
    if (cap) {
      const text = cap[1].charAt(cap[1].length - 1) === "\n" ? cap[1].slice(0, -1) : cap[1];
      return {
        type: "paragraph",
        raw: cap[0],
        text,
        tokens: this.lexer.inline(text)
      };
    }
  }
  text(src) {
    const cap = this.rules.block.text.exec(src);
    if (cap) {
      return {
        type: "text",
        raw: cap[0],
        text: cap[0],
        tokens: this.lexer.inline(cap[0])
      };
    }
  }
  escape(src) {
    const cap = this.rules.inline.escape.exec(src);
    if (cap) {
      return {
        type: "escape",
        raw: cap[0],
        text: escape(cap[1])
      };
    }
  }
  tag(src) {
    const cap = this.rules.inline.tag.exec(src);
    if (cap) {
      if (!this.lexer.state.inLink && /^<a /i.test(cap[0])) {
        this.lexer.state.inLink = true;
      } else if (this.lexer.state.inLink && /^<\/a>/i.test(cap[0])) {
        this.lexer.state.inLink = false;
      }
      if (!this.lexer.state.inRawBlock && /^<(pre|code|kbd|script)(\s|>)/i.test(cap[0])) {
        this.lexer.state.inRawBlock = true;
      } else if (this.lexer.state.inRawBlock && /^<\/(pre|code|kbd|script)(\s|>)/i.test(cap[0])) {
        this.lexer.state.inRawBlock = false;
      }
      return {
        type: this.options.sanitize ? "text" : "html",
        raw: cap[0],
        inLink: this.lexer.state.inLink,
        inRawBlock: this.lexer.state.inRawBlock,
        text: this.options.sanitize ? this.options.sanitizer ? this.options.sanitizer(cap[0]) : escape(cap[0]) : cap[0]
      };
    }
  }
  link(src) {
    const cap = this.rules.inline.link.exec(src);
    if (cap) {
      const trimmedUrl = cap[2].trim();
      if (!this.options.pedantic && /^</.test(trimmedUrl)) {
        if (!/>$/.test(trimmedUrl)) {
          return;
        }
        const rtrimSlash = rtrim(trimmedUrl.slice(0, -1), "\\");
        if ((trimmedUrl.length - rtrimSlash.length) % 2 === 0) {
          return;
        }
      } else {
        const lastParenIndex = findClosingBracket(cap[2], "()");
        if (lastParenIndex > -1) {
          const start = cap[0].indexOf("!") === 0 ? 5 : 4;
          const linkLen = start + cap[1].length + lastParenIndex;
          cap[2] = cap[2].substring(0, lastParenIndex);
          cap[0] = cap[0].substring(0, linkLen).trim();
          cap[3] = "";
        }
      }
      let href = cap[2];
      let title = "";
      if (this.options.pedantic) {
        const link = /^([^'"]*[^\s])\s+(['"])(.*)\2/.exec(href);
        if (link) {
          href = link[1];
          title = link[3];
        }
      } else {
        title = cap[3] ? cap[3].slice(1, -1) : "";
      }
      href = href.trim();
      if (/^</.test(href)) {
        if (this.options.pedantic && !/>$/.test(trimmedUrl)) {
          href = href.slice(1);
        } else {
          href = href.slice(1, -1);
        }
      }
      return outputLink(cap, {
        href: href ? href.replace(this.rules.inline._escapes, "$1") : href,
        title: title ? title.replace(this.rules.inline._escapes, "$1") : title
      }, cap[0], this.lexer);
    }
  }
  reflink(src, links) {
    let cap;
    if ((cap = this.rules.inline.reflink.exec(src)) || (cap = this.rules.inline.nolink.exec(src))) {
      let link = (cap[2] || cap[1]).replace(/\s+/g, " ");
      link = links[link.toLowerCase()];
      if (!link) {
        const text = cap[0].charAt(0);
        return {
          type: "text",
          raw: text,
          text
        };
      }
      return outputLink(cap, link, cap[0], this.lexer);
    }
  }
  emStrong(src, maskedSrc, prevChar = "") {
    let match = this.rules.inline.emStrong.lDelim.exec(src);
    if (!match)
      return;
    if (match[3] && prevChar.match(/[\p{L}\p{N}]/u))
      return;
    const nextChar = match[1] || match[2] || "";
    if (!nextChar || nextChar && (prevChar === "" || this.rules.inline.punctuation.exec(prevChar))) {
      const lLength = match[0].length - 1;
      let rDelim, rLength, delimTotal = lLength, midDelimTotal = 0;
      const endReg = match[0][0] === "*" ? this.rules.inline.emStrong.rDelimAst : this.rules.inline.emStrong.rDelimUnd;
      endReg.lastIndex = 0;
      maskedSrc = maskedSrc.slice(-1 * src.length + lLength);
      while ((match = endReg.exec(maskedSrc)) != null) {
        rDelim = match[1] || match[2] || match[3] || match[4] || match[5] || match[6];
        if (!rDelim)
          continue;
        rLength = rDelim.length;
        if (match[3] || match[4]) {
          delimTotal += rLength;
          continue;
        } else if (match[5] || match[6]) {
          if (lLength % 3 && !((lLength + rLength) % 3)) {
            midDelimTotal += rLength;
            continue;
          }
        }
        delimTotal -= rLength;
        if (delimTotal > 0)
          continue;
        rLength = Math.min(rLength, rLength + delimTotal + midDelimTotal);
        const raw = src.slice(0, lLength + match.index + (match[0].length - rDelim.length) + rLength);
        if (Math.min(lLength, rLength) % 2) {
          const text2 = raw.slice(1, -1);
          return {
            type: "em",
            raw,
            text: text2,
            tokens: this.lexer.inlineTokens(text2)
          };
        }
        const text = raw.slice(2, -2);
        return {
          type: "strong",
          raw,
          text,
          tokens: this.lexer.inlineTokens(text)
        };
      }
    }
  }
  codespan(src) {
    const cap = this.rules.inline.code.exec(src);
    if (cap) {
      let text = cap[2].replace(/\n/g, " ");
      const hasNonSpaceChars = /[^ ]/.test(text);
      const hasSpaceCharsOnBothEnds = /^ /.test(text) && / $/.test(text);
      if (hasNonSpaceChars && hasSpaceCharsOnBothEnds) {
        text = text.substring(1, text.length - 1);
      }
      text = escape(text, true);
      return {
        type: "codespan",
        raw: cap[0],
        text
      };
    }
  }
  br(src) {
    const cap = this.rules.inline.br.exec(src);
    if (cap) {
      return {
        type: "br",
        raw: cap[0]
      };
    }
  }
  del(src) {
    const cap = this.rules.inline.del.exec(src);
    if (cap) {
      return {
        type: "del",
        raw: cap[0],
        text: cap[2],
        tokens: this.lexer.inlineTokens(cap[2])
      };
    }
  }
  autolink(src, mangle2) {
    const cap = this.rules.inline.autolink.exec(src);
    if (cap) {
      let text, href;
      if (cap[2] === "@") {
        text = escape(this.options.mangle ? mangle2(cap[1]) : cap[1]);
        href = "mailto:" + text;
      } else {
        text = escape(cap[1]);
        href = text;
      }
      return {
        type: "link",
        raw: cap[0],
        text,
        href,
        tokens: [
          {
            type: "text",
            raw: text,
            text
          }
        ]
      };
    }
  }
  url(src, mangle2) {
    let cap;
    if (cap = this.rules.inline.url.exec(src)) {
      let text, href;
      if (cap[2] === "@") {
        text = escape(this.options.mangle ? mangle2(cap[0]) : cap[0]);
        href = "mailto:" + text;
      } else {
        let prevCapZero;
        do {
          prevCapZero = cap[0];
          cap[0] = this.rules.inline._backpedal.exec(cap[0])[0];
        } while (prevCapZero !== cap[0]);
        text = escape(cap[0]);
        if (cap[1] === "www.") {
          href = "http://" + cap[0];
        } else {
          href = cap[0];
        }
      }
      return {
        type: "link",
        raw: cap[0],
        text,
        href,
        tokens: [
          {
            type: "text",
            raw: text,
            text
          }
        ]
      };
    }
  }
  inlineText(src, smartypants2) {
    const cap = this.rules.inline.text.exec(src);
    if (cap) {
      let text;
      if (this.lexer.state.inRawBlock) {
        text = this.options.sanitize ? this.options.sanitizer ? this.options.sanitizer(cap[0]) : escape(cap[0]) : cap[0];
      } else {
        text = escape(this.options.smartypants ? smartypants2(cap[0]) : cap[0]);
      }
      return {
        type: "text",
        raw: cap[0],
        text
      };
    }
  }
};
var block = {
  newline: /^(?: *(?:\n|$))+/,
  code: /^( {4}[^\n]+(?:\n(?: *(?:\n|$))*)?)+/,
  fences: /^ {0,3}(`{3,}(?=[^`\n]*(?:\n|$))|~{3,})([^\n]*)(?:\n|$)(?:|([\s\S]*?)(?:\n|$))(?: {0,3}\1[~`]* *(?=\n|$)|$)/,
  hr: /^ {0,3}((?:-[\t ]*){3,}|(?:_[ \t]*){3,}|(?:\*[ \t]*){3,})(?:\n+|$)/,
  heading: /^ {0,3}(#{1,6})(?=\s|$)(.*)(?:\n+|$)/,
  blockquote: /^( {0,3}> ?(paragraph|[^\n]*)(?:\n|$))+/,
  list: /^( {0,3}bull)([ \t][^\n]+?)?(?:\n|$)/,
  html: "^ {0,3}(?:<(script|pre|style|textarea)[\\s>][\\s\\S]*?(?:</\\1>[^\\n]*\\n+|$)|comment[^\\n]*(\\n+|$)|<\\?[\\s\\S]*?(?:\\?>\\n*|$)|<![A-Z][\\s\\S]*?(?:>\\n*|$)|<!\\[CDATA\\[[\\s\\S]*?(?:\\]\\]>\\n*|$)|</?(tag)(?: +|\\n|/?>)[\\s\\S]*?(?:(?:\\n *)+\\n|$)|<(?!script|pre|style|textarea)([a-z][\\w-]*)(?:attribute)*? */?>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n *)+\\n|$)|</(?!script|pre|style|textarea)[a-z][\\w-]*\\s*>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n *)+\\n|$))",
  def: /^ {0,3}\[(label)\]: *(?:\n *)?([^<\s][^\s]*|<.*?>)(?:(?: +(?:\n *)?| *\n *)(title))? *(?:\n+|$)/,
  table: noopTest,
  lheading: /^((?:.|\n(?!\n))+?)\n {0,3}(=+|-+) *(?:\n+|$)/,
  // regex template, placeholders will be replaced according to different paragraph
  // interruption rules of commonmark and the original markdown spec:
  _paragraph: /^([^\n]+(?:\n(?!hr|heading|lheading|blockquote|fences|list|html|table| +\n)[^\n]+)*)/,
  text: /^[^\n]+/
};
block._label = /(?!\s*\])(?:\\.|[^\[\]\\])+/;
block._title = /(?:"(?:\\"?|[^"\\])*"|'[^'\n]*(?:\n[^'\n]+)*\n?'|\([^()]*\))/;
block.def = edit(block.def).replace("label", block._label).replace("title", block._title).getRegex();
block.bullet = /(?:[*+-]|\d{1,9}[.)])/;
block.listItemStart = edit(/^( *)(bull) */).replace("bull", block.bullet).getRegex();
block.list = edit(block.list).replace(/bull/g, block.bullet).replace("hr", "\\n+(?=\\1?(?:(?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$))").replace("def", "\\n+(?=" + block.def.source + ")").getRegex();
block._tag = "address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option|p|param|section|source|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul";
block._comment = /<!--(?!-?>)[\s\S]*?(?:-->|$)/;
block.html = edit(block.html, "i").replace("comment", block._comment).replace("tag", block._tag).replace("attribute", / +[a-zA-Z:_][\w.:-]*(?: *= *"[^"\n]*"| *= *'[^'\n]*'| *= *[^\s"'=<>`]+)?/).getRegex();
block.paragraph = edit(block._paragraph).replace("hr", block.hr).replace("heading", " {0,3}#{1,6} ").replace("|lheading", "").replace("|table", "").replace("blockquote", " {0,3}>").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", block._tag).getRegex();
block.blockquote = edit(block.blockquote).replace("paragraph", block.paragraph).getRegex();
block.normal = { ...block };
block.gfm = {
  ...block.normal,
  table: "^ *([^\\n ].*\\|.*)\\n {0,3}(?:\\| *)?(:?-+:? *(?:\\| *:?-+:? *)*)(?:\\| *)?(?:\\n((?:(?! *\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\n|$))*)\\n*|$)"
  // Cells
};
block.gfm.table = edit(block.gfm.table).replace("hr", block.hr).replace("heading", " {0,3}#{1,6} ").replace("blockquote", " {0,3}>").replace("code", " {4}[^\\n]").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", block._tag).getRegex();
block.gfm.paragraph = edit(block._paragraph).replace("hr", block.hr).replace("heading", " {0,3}#{1,6} ").replace("|lheading", "").replace("table", block.gfm.table).replace("blockquote", " {0,3}>").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", block._tag).getRegex();
block.pedantic = {
  ...block.normal,
  html: edit(
    `^ *(?:comment *(?:\\n|\\s*$)|<(tag)[\\s\\S]+?</\\1> *(?:\\n{2,}|\\s*$)|<tag(?:"[^"]*"|'[^']*'|\\s[^'"/>\\s]*)*?/?> *(?:\\n{2,}|\\s*$))`
  ).replace("comment", block._comment).replace(/tag/g, "(?!(?:a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)\\b)\\w+(?!:|[^\\w\\s@]*@)\\b").getRegex(),
  def: /^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +(["(][^\n]+[")]))? *(?:\n+|$)/,
  heading: /^(#{1,6})(.*)(?:\n+|$)/,
  fences: noopTest,
  // fences not supported
  lheading: /^(.+?)\n {0,3}(=+|-+) *(?:\n+|$)/,
  paragraph: edit(block.normal._paragraph).replace("hr", block.hr).replace("heading", " *#{1,6} *[^\n]").replace("lheading", block.lheading).replace("blockquote", " {0,3}>").replace("|fences", "").replace("|list", "").replace("|html", "").getRegex()
};
var inline = {
  escape: /^\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/,
  autolink: /^<(scheme:[^\s\x00-\x1f<>]*|email)>/,
  url: noopTest,
  tag: "^comment|^</[a-zA-Z][\\w:-]*\\s*>|^<[a-zA-Z][\\w-]*(?:attribute)*?\\s*/?>|^<\\?[\\s\\S]*?\\?>|^<![a-zA-Z]+\\s[\\s\\S]*?>|^<!\\[CDATA\\[[\\s\\S]*?\\]\\]>",
  // CDATA section
  link: /^!?\[(label)\]\(\s*(href)(?:\s+(title))?\s*\)/,
  reflink: /^!?\[(label)\]\[(ref)\]/,
  nolink: /^!?\[(ref)\](?:\[\])?/,
  reflinkSearch: "reflink|nolink(?!\\()",
  emStrong: {
    lDelim: /^(?:\*+(?:([punct_])|[^\s*]))|^_+(?:([punct*])|([^\s_]))/,
    //        (1) and (2) can only be a Right Delimiter. (3) and (4) can only be Left.  (5) and (6) can be either Left or Right.
    //          () Skip orphan inside strong                                      () Consume to delim     (1) #***                (2) a***#, a***                             (3) #***a, ***a                 (4) ***#              (5) #***#                 (6) a***a
    rDelimAst: /^(?:[^_*\\]|\\.)*?\_\_(?:[^_*\\]|\\.)*?\*(?:[^_*\\]|\\.)*?(?=\_\_)|(?:[^*\\]|\\.)+(?=[^*])|[punct_](\*+)(?=[\s]|$)|(?:[^punct*_\s\\]|\\.)(\*+)(?=[punct_\s]|$)|[punct_\s](\*+)(?=[^punct*_\s])|[\s](\*+)(?=[punct_])|[punct_](\*+)(?=[punct_])|(?:[^punct*_\s\\]|\\.)(\*+)(?=[^punct*_\s])/,
    rDelimUnd: /^(?:[^_*\\]|\\.)*?\*\*(?:[^_*\\]|\\.)*?\_(?:[^_*\\]|\\.)*?(?=\*\*)|(?:[^_\\]|\\.)+(?=[^_])|[punct*](\_+)(?=[\s]|$)|(?:[^punct*_\s\\]|\\.)(\_+)(?=[punct*\s]|$)|[punct*\s](\_+)(?=[^punct*_\s])|[\s](\_+)(?=[punct*])|[punct*](\_+)(?=[punct*])/
    // ^- Not allowed for _
  },
  code: /^(`+)([^`]|[^`][\s\S]*?[^`])\1(?!`)/,
  br: /^( {2,}|\\)\n(?!\s*$)/,
  del: noopTest,
  text: /^(`+|[^`])(?:(?= {2,}\n)|[\s\S]*?(?:(?=[\\<!\[`*_]|\b_|$)|[^ ](?= {2,}\n)))/,
  punctuation: /^([\spunctuation])/
};
inline._punctuation = "!\"#$%&'()+\\-.,/:;<=>?@\\[\\]`^{|}~";
inline.punctuation = edit(inline.punctuation).replace(/punctuation/g, inline._punctuation).getRegex();
inline.blockSkip = /\[[^\]]*?\]\([^\)]*?\)|`[^`]*?`|<[^>]*?>/g;
inline.escapedEmSt = /(?:^|[^\\])(?:\\\\)*\\[*_]/g;
inline._comment = edit(block._comment).replace("(?:-->|$)", "-->").getRegex();
inline.emStrong.lDelim = edit(inline.emStrong.lDelim).replace(/punct/g, inline._punctuation).getRegex();
inline.emStrong.rDelimAst = edit(inline.emStrong.rDelimAst, "g").replace(/punct/g, inline._punctuation).getRegex();
inline.emStrong.rDelimUnd = edit(inline.emStrong.rDelimUnd, "g").replace(/punct/g, inline._punctuation).getRegex();
inline._escapes = /\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/g;
inline._scheme = /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/;
inline._email = /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/;
inline.autolink = edit(inline.autolink).replace("scheme", inline._scheme).replace("email", inline._email).getRegex();
inline._attribute = /\s+[a-zA-Z:_][\w.:-]*(?:\s*=\s*"[^"]*"|\s*=\s*'[^']*'|\s*=\s*[^\s"'=<>`]+)?/;
inline.tag = edit(inline.tag).replace("comment", inline._comment).replace("attribute", inline._attribute).getRegex();
inline._label = /(?:\[(?:\\.|[^\[\]\\])*\]|\\.|`[^`]*`|[^\[\]\\`])*?/;
inline._href = /<(?:\\.|[^\n<>\\])+>|[^\s\x00-\x1f]*/;
inline._title = /"(?:\\"?|[^"\\])*"|'(?:\\'?|[^'\\])*'|\((?:\\\)?|[^)\\])*\)/;
inline.link = edit(inline.link).replace("label", inline._label).replace("href", inline._href).replace("title", inline._title).getRegex();
inline.reflink = edit(inline.reflink).replace("label", inline._label).replace("ref", block._label).getRegex();
inline.nolink = edit(inline.nolink).replace("ref", block._label).getRegex();
inline.reflinkSearch = edit(inline.reflinkSearch, "g").replace("reflink", inline.reflink).replace("nolink", inline.nolink).getRegex();
inline.normal = { ...inline };
inline.pedantic = {
  ...inline.normal,
  strong: {
    start: /^__|\*\*/,
    middle: /^__(?=\S)([\s\S]*?\S)__(?!_)|^\*\*(?=\S)([\s\S]*?\S)\*\*(?!\*)/,
    endAst: /\*\*(?!\*)/g,
    endUnd: /__(?!_)/g
  },
  em: {
    start: /^_|\*/,
    middle: /^()\*(?=\S)([\s\S]*?\S)\*(?!\*)|^_(?=\S)([\s\S]*?\S)_(?!_)/,
    endAst: /\*(?!\*)/g,
    endUnd: /_(?!_)/g
  },
  link: edit(/^!?\[(label)\]\((.*?)\)/).replace("label", inline._label).getRegex(),
  reflink: edit(/^!?\[(label)\]\s*\[([^\]]*)\]/).replace("label", inline._label).getRegex()
};
inline.gfm = {
  ...inline.normal,
  escape: edit(inline.escape).replace("])", "~|])").getRegex(),
  _extended_email: /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/,
  url: /^((?:ftp|https?):\/\/|www\.)(?:[a-zA-Z0-9\-]+\.?)+[^\s<]*|^email/,
  _backpedal: /(?:[^?!.,:;*_'"~()&]+|\([^)]*\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_'"~)]+(?!$))+/,
  del: /^(~~?)(?=[^\s~])([\s\S]*?[^\s~])\1(?=[^~]|$)/,
  text: /^([`~]+|[^`~])(?:(?= {2,}\n)|(?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)|[\s\S]*?(?:(?=[\\<!\[`*~_]|\b_|https?:\/\/|ftp:\/\/|www\.|$)|[^ ](?= {2,}\n)|[^a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-](?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)))/
};
inline.gfm.url = edit(inline.gfm.url, "i").replace("email", inline.gfm._extended_email).getRegex();
inline.breaks = {
  ...inline.gfm,
  br: edit(inline.br).replace("{2,}", "*").getRegex(),
  text: edit(inline.gfm.text).replace("\\b_", "\\b_| {2,}\\n").replace(/\{2,\}/g, "*").getRegex()
};
function smartypants(text) {
  return text.replace(/---/g, "\u2014").replace(/--/g, "\u2013").replace(/(^|[-\u2014/(\[{"\s])'/g, "$1\u2018").replace(/'/g, "\u2019").replace(/(^|[-\u2014/(\[{\u2018\s])"/g, "$1\u201C").replace(/"/g, "\u201D").replace(/\.{3}/g, "\u2026");
}
function mangle(text) {
  let out = "", i, ch;
  const l = text.length;
  for (i = 0; i < l; i++) {
    ch = text.charCodeAt(i);
    if (Math.random() > 0.5) {
      ch = "x" + ch.toString(16);
    }
    out += "&#" + ch + ";";
  }
  return out;
}
var Lexer = class {
  constructor(options2) {
    this.tokens = [];
    this.tokens.links = /* @__PURE__ */ Object.create(null);
    this.options = options2 || defaults;
    this.options.tokenizer = this.options.tokenizer || new Tokenizer();
    this.tokenizer = this.options.tokenizer;
    this.tokenizer.options = this.options;
    this.tokenizer.lexer = this;
    this.inlineQueue = [];
    this.state = {
      inLink: false,
      inRawBlock: false,
      top: true
    };
    const rules = {
      block: block.normal,
      inline: inline.normal
    };
    if (this.options.pedantic) {
      rules.block = block.pedantic;
      rules.inline = inline.pedantic;
    } else if (this.options.gfm) {
      rules.block = block.gfm;
      if (this.options.breaks) {
        rules.inline = inline.breaks;
      } else {
        rules.inline = inline.gfm;
      }
    }
    this.tokenizer.rules = rules;
  }
  /**
   * Expose Rules
   */
  static get rules() {
    return {
      block,
      inline
    };
  }
  /**
   * Static Lex Method
   */
  static lex(src, options2) {
    const lexer2 = new Lexer(options2);
    return lexer2.lex(src);
  }
  /**
   * Static Lex Inline Method
   */
  static lexInline(src, options2) {
    const lexer2 = new Lexer(options2);
    return lexer2.inlineTokens(src);
  }
  /**
   * Preprocessing
   */
  lex(src) {
    src = src.replace(/\r\n|\r/g, "\n");
    this.blockTokens(src, this.tokens);
    let next;
    while (next = this.inlineQueue.shift()) {
      this.inlineTokens(next.src, next.tokens);
    }
    return this.tokens;
  }
  /**
   * Lexing
   */
  blockTokens(src, tokens = []) {
    if (this.options.pedantic) {
      src = src.replace(/\t/g, "    ").replace(/^ +$/gm, "");
    } else {
      src = src.replace(/^( *)(\t+)/gm, (_, leading, tabs) => {
        return leading + "    ".repeat(tabs.length);
      });
    }
    let token, lastToken, cutSrc, lastParagraphClipped;
    while (src) {
      if (this.options.extensions && this.options.extensions.block && this.options.extensions.block.some((extTokenizer) => {
        if (token = extTokenizer.call({ lexer: this }, src, tokens)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          return true;
        }
        return false;
      })) {
        continue;
      }
      if (token = this.tokenizer.space(src)) {
        src = src.substring(token.raw.length);
        if (token.raw.length === 1 && tokens.length > 0) {
          tokens[tokens.length - 1].raw += "\n";
        } else {
          tokens.push(token);
        }
        continue;
      }
      if (token = this.tokenizer.code(src)) {
        src = src.substring(token.raw.length);
        lastToken = tokens[tokens.length - 1];
        if (lastToken && (lastToken.type === "paragraph" || lastToken.type === "text")) {
          lastToken.raw += "\n" + token.raw;
          lastToken.text += "\n" + token.text;
          this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;
        } else {
          tokens.push(token);
        }
        continue;
      }
      if (token = this.tokenizer.fences(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.heading(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.hr(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.blockquote(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.list(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.html(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.def(src)) {
        src = src.substring(token.raw.length);
        lastToken = tokens[tokens.length - 1];
        if (lastToken && (lastToken.type === "paragraph" || lastToken.type === "text")) {
          lastToken.raw += "\n" + token.raw;
          lastToken.text += "\n" + token.raw;
          this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;
        } else if (!this.tokens.links[token.tag]) {
          this.tokens.links[token.tag] = {
            href: token.href,
            title: token.title
          };
        }
        continue;
      }
      if (token = this.tokenizer.table(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.lheading(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      cutSrc = src;
      if (this.options.extensions && this.options.extensions.startBlock) {
        let startIndex = Infinity;
        const tempSrc = src.slice(1);
        let tempStart;
        this.options.extensions.startBlock.forEach(function(getStartIndex) {
          tempStart = getStartIndex.call({ lexer: this }, tempSrc);
          if (typeof tempStart === "number" && tempStart >= 0) {
            startIndex = Math.min(startIndex, tempStart);
          }
        });
        if (startIndex < Infinity && startIndex >= 0) {
          cutSrc = src.substring(0, startIndex + 1);
        }
      }
      if (this.state.top && (token = this.tokenizer.paragraph(cutSrc))) {
        lastToken = tokens[tokens.length - 1];
        if (lastParagraphClipped && lastToken.type === "paragraph") {
          lastToken.raw += "\n" + token.raw;
          lastToken.text += "\n" + token.text;
          this.inlineQueue.pop();
          this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;
        } else {
          tokens.push(token);
        }
        lastParagraphClipped = cutSrc.length !== src.length;
        src = src.substring(token.raw.length);
        continue;
      }
      if (token = this.tokenizer.text(src)) {
        src = src.substring(token.raw.length);
        lastToken = tokens[tokens.length - 1];
        if (lastToken && lastToken.type === "text") {
          lastToken.raw += "\n" + token.raw;
          lastToken.text += "\n" + token.text;
          this.inlineQueue.pop();
          this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;
        } else {
          tokens.push(token);
        }
        continue;
      }
      if (src) {
        const errMsg = "Infinite loop on byte: " + src.charCodeAt(0);
        if (this.options.silent) {
          console.error(errMsg);
          break;
        } else {
          throw new Error(errMsg);
        }
      }
    }
    this.state.top = true;
    return tokens;
  }
  inline(src, tokens = []) {
    this.inlineQueue.push({ src, tokens });
    return tokens;
  }
  /**
   * Lexing/Compiling
   */
  inlineTokens(src, tokens = []) {
    let token, lastToken, cutSrc;
    let maskedSrc = src;
    let match;
    let keepPrevChar, prevChar;
    if (this.tokens.links) {
      const links = Object.keys(this.tokens.links);
      if (links.length > 0) {
        while ((match = this.tokenizer.rules.inline.reflinkSearch.exec(maskedSrc)) != null) {
          if (links.includes(match[0].slice(match[0].lastIndexOf("[") + 1, -1))) {
            maskedSrc = maskedSrc.slice(0, match.index) + "[" + repeatString("a", match[0].length - 2) + "]" + maskedSrc.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex);
          }
        }
      }
    }
    while ((match = this.tokenizer.rules.inline.blockSkip.exec(maskedSrc)) != null) {
      maskedSrc = maskedSrc.slice(0, match.index) + "[" + repeatString("a", match[0].length - 2) + "]" + maskedSrc.slice(this.tokenizer.rules.inline.blockSkip.lastIndex);
    }
    while ((match = this.tokenizer.rules.inline.escapedEmSt.exec(maskedSrc)) != null) {
      maskedSrc = maskedSrc.slice(0, match.index + match[0].length - 2) + "++" + maskedSrc.slice(this.tokenizer.rules.inline.escapedEmSt.lastIndex);
      this.tokenizer.rules.inline.escapedEmSt.lastIndex--;
    }
    while (src) {
      if (!keepPrevChar) {
        prevChar = "";
      }
      keepPrevChar = false;
      if (this.options.extensions && this.options.extensions.inline && this.options.extensions.inline.some((extTokenizer) => {
        if (token = extTokenizer.call({ lexer: this }, src, tokens)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          return true;
        }
        return false;
      })) {
        continue;
      }
      if (token = this.tokenizer.escape(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.tag(src)) {
        src = src.substring(token.raw.length);
        lastToken = tokens[tokens.length - 1];
        if (lastToken && token.type === "text" && lastToken.type === "text") {
          lastToken.raw += token.raw;
          lastToken.text += token.text;
        } else {
          tokens.push(token);
        }
        continue;
      }
      if (token = this.tokenizer.link(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.reflink(src, this.tokens.links)) {
        src = src.substring(token.raw.length);
        lastToken = tokens[tokens.length - 1];
        if (lastToken && token.type === "text" && lastToken.type === "text") {
          lastToken.raw += token.raw;
          lastToken.text += token.text;
        } else {
          tokens.push(token);
        }
        continue;
      }
      if (token = this.tokenizer.emStrong(src, maskedSrc, prevChar)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.codespan(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.br(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.del(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.autolink(src, mangle)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (!this.state.inLink && (token = this.tokenizer.url(src, mangle))) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      cutSrc = src;
      if (this.options.extensions && this.options.extensions.startInline) {
        let startIndex = Infinity;
        const tempSrc = src.slice(1);
        let tempStart;
        this.options.extensions.startInline.forEach(function(getStartIndex) {
          tempStart = getStartIndex.call({ lexer: this }, tempSrc);
          if (typeof tempStart === "number" && tempStart >= 0) {
            startIndex = Math.min(startIndex, tempStart);
          }
        });
        if (startIndex < Infinity && startIndex >= 0) {
          cutSrc = src.substring(0, startIndex + 1);
        }
      }
      if (token = this.tokenizer.inlineText(cutSrc, smartypants)) {
        src = src.substring(token.raw.length);
        if (token.raw.slice(-1) !== "_") {
          prevChar = token.raw.slice(-1);
        }
        keepPrevChar = true;
        lastToken = tokens[tokens.length - 1];
        if (lastToken && lastToken.type === "text") {
          lastToken.raw += token.raw;
          lastToken.text += token.text;
        } else {
          tokens.push(token);
        }
        continue;
      }
      if (src) {
        const errMsg = "Infinite loop on byte: " + src.charCodeAt(0);
        if (this.options.silent) {
          console.error(errMsg);
          break;
        } else {
          throw new Error(errMsg);
        }
      }
    }
    return tokens;
  }
};
var Renderer = class {
  constructor(options2) {
    this.options = options2 || defaults;
  }
  code(code, infostring, escaped) {
    const lang = (infostring || "").match(/\S*/)[0];
    if (this.options.highlight) {
      const out = this.options.highlight(code, lang);
      if (out != null && out !== code) {
        escaped = true;
        code = out;
      }
    }
    code = code.replace(/\n$/, "") + "\n";
    if (!lang) {
      return "<pre><code>" + (escaped ? code : escape(code, true)) + "</code></pre>\n";
    }
    return '<pre><code class="' + this.options.langPrefix + escape(lang) + '">' + (escaped ? code : escape(code, true)) + "</code></pre>\n";
  }
  /**
   * @param {string} quote
   */
  blockquote(quote) {
    return `<blockquote>
${quote}</blockquote>
`;
  }
  html(html) {
    return html;
  }
  /**
   * @param {string} text
   * @param {string} level
   * @param {string} raw
   * @param {any} slugger
   */
  heading(text, level, raw, slugger) {
    if (this.options.headerIds) {
      const id = this.options.headerPrefix + slugger.slug(raw);
      return `<h${level} id="${id}">${text}</h${level}>
`;
    }
    return `<h${level}>${text}</h${level}>
`;
  }
  hr() {
    return this.options.xhtml ? "<hr/>\n" : "<hr>\n";
  }
  list(body, ordered, start) {
    const type = ordered ? "ol" : "ul", startatt = ordered && start !== 1 ? ' start="' + start + '"' : "";
    return "<" + type + startatt + ">\n" + body + "</" + type + ">\n";
  }
  /**
   * @param {string} text
   */
  listitem(text) {
    return `<li>${text}</li>
`;
  }
  checkbox(checked) {
    return "<input " + (checked ? 'checked="" ' : "") + 'disabled="" type="checkbox"' + (this.options.xhtml ? " /" : "") + "> ";
  }
  /**
   * @param {string} text
   */
  paragraph(text) {
    return `<p>${text}</p>
`;
  }
  /**
   * @param {string} header
   * @param {string} body
   */
  table(header, body) {
    if (body)
      body = `<tbody>${body}</tbody>`;
    return "<table>\n<thead>\n" + header + "</thead>\n" + body + "</table>\n";
  }
  /**
   * @param {string} content
   */
  tablerow(content) {
    return `<tr>
${content}</tr>
`;
  }
  tablecell(content, flags) {
    const type = flags.header ? "th" : "td";
    const tag = flags.align ? `<${type} align="${flags.align}">` : `<${type}>`;
    return tag + content + `</${type}>
`;
  }
  /**
   * span level renderer
   * @param {string} text
   */
  strong(text) {
    return `<strong>${text}</strong>`;
  }
  /**
   * @param {string} text
   */
  em(text) {
    return `<em>${text}</em>`;
  }
  /**
   * @param {string} text
   */
  codespan(text) {
    return `<code>${text}</code>`;
  }
  br() {
    return this.options.xhtml ? "<br/>" : "<br>";
  }
  /**
   * @param {string} text
   */
  del(text) {
    return `<del>${text}</del>`;
  }
  /**
   * @param {string} href
   * @param {string} title
   * @param {string} text
   */
  link(href, title, text) {
    href = cleanUrl(this.options.sanitize, this.options.baseUrl, href);
    if (href === null) {
      return text;
    }
    let out = '<a href="' + href + '"';
    if (title) {
      out += ' title="' + title + '"';
    }
    out += ">" + text + "</a>";
    return out;
  }
  /**
   * @param {string} href
   * @param {string} title
   * @param {string} text
   */
  image(href, title, text) {
    href = cleanUrl(this.options.sanitize, this.options.baseUrl, href);
    if (href === null) {
      return text;
    }
    let out = `<img src="${href}" alt="${text}"`;
    if (title) {
      out += ` title="${title}"`;
    }
    out += this.options.xhtml ? "/>" : ">";
    return out;
  }
  text(text) {
    return text;
  }
};
var TextRenderer = class {
  // no need for block level renderers
  strong(text) {
    return text;
  }
  em(text) {
    return text;
  }
  codespan(text) {
    return text;
  }
  del(text) {
    return text;
  }
  html(text) {
    return text;
  }
  text(text) {
    return text;
  }
  link(href, title, text) {
    return "" + text;
  }
  image(href, title, text) {
    return "" + text;
  }
  br() {
    return "";
  }
};
var Slugger = class {
  constructor() {
    this.seen = {};
  }
  /**
   * @param {string} value
   */
  serialize(value) {
    return value.toLowerCase().trim().replace(/<[!\/a-z].*?>/ig, "").replace(/[\u2000-\u206F\u2E00-\u2E7F\\'!"#$%&()*+,./:;<=>?@[\]^`{|}~]/g, "").replace(/\s/g, "-");
  }
  /**
   * Finds the next safe (unique) slug to use
   * @param {string} originalSlug
   * @param {boolean} isDryRun
   */
  getNextSafeSlug(originalSlug, isDryRun) {
    let slug = originalSlug;
    let occurenceAccumulator = 0;
    if (this.seen.hasOwnProperty(slug)) {
      occurenceAccumulator = this.seen[originalSlug];
      do {
        occurenceAccumulator++;
        slug = originalSlug + "-" + occurenceAccumulator;
      } while (this.seen.hasOwnProperty(slug));
    }
    if (!isDryRun) {
      this.seen[originalSlug] = occurenceAccumulator;
      this.seen[slug] = 0;
    }
    return slug;
  }
  /**
   * Convert string to unique id
   * @param {object} [options]
   * @param {boolean} [options.dryrun] Generates the next unique slug without
   * updating the internal accumulator.
   */
  slug(value, options2 = {}) {
    const slug = this.serialize(value);
    return this.getNextSafeSlug(slug, options2.dryrun);
  }
};
var Parser = class {
  constructor(options2) {
    this.options = options2 || defaults;
    this.options.renderer = this.options.renderer || new Renderer();
    this.renderer = this.options.renderer;
    this.renderer.options = this.options;
    this.textRenderer = new TextRenderer();
    this.slugger = new Slugger();
  }
  /**
   * Static Parse Method
   */
  static parse(tokens, options2) {
    const parser2 = new Parser(options2);
    return parser2.parse(tokens);
  }
  /**
   * Static Parse Inline Method
   */
  static parseInline(tokens, options2) {
    const parser2 = new Parser(options2);
    return parser2.parseInline(tokens);
  }
  /**
   * Parse Loop
   */
  parse(tokens, top = true) {
    let out = "", i, j, k, l2, l3, row, cell, header, body, token, ordered, start, loose, itemBody, item, checked, task, checkbox, ret;
    const l = tokens.length;
    for (i = 0; i < l; i++) {
      token = tokens[i];
      if (this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[token.type]) {
        ret = this.options.extensions.renderers[token.type].call({ parser: this }, token);
        if (ret !== false || !["space", "hr", "heading", "code", "table", "blockquote", "list", "html", "paragraph", "text"].includes(token.type)) {
          out += ret || "";
          continue;
        }
      }
      switch (token.type) {
        case "space": {
          continue;
        }
        case "hr": {
          out += this.renderer.hr();
          continue;
        }
        case "heading": {
          out += this.renderer.heading(
            this.parseInline(token.tokens),
            token.depth,
            unescape(this.parseInline(token.tokens, this.textRenderer)),
            this.slugger
          );
          continue;
        }
        case "code": {
          out += this.renderer.code(
            token.text,
            token.lang,
            token.escaped
          );
          continue;
        }
        case "table": {
          header = "";
          cell = "";
          l2 = token.header.length;
          for (j = 0; j < l2; j++) {
            cell += this.renderer.tablecell(
              this.parseInline(token.header[j].tokens),
              { header: true, align: token.align[j] }
            );
          }
          header += this.renderer.tablerow(cell);
          body = "";
          l2 = token.rows.length;
          for (j = 0; j < l2; j++) {
            row = token.rows[j];
            cell = "";
            l3 = row.length;
            for (k = 0; k < l3; k++) {
              cell += this.renderer.tablecell(
                this.parseInline(row[k].tokens),
                { header: false, align: token.align[k] }
              );
            }
            body += this.renderer.tablerow(cell);
          }
          out += this.renderer.table(header, body);
          continue;
        }
        case "blockquote": {
          body = this.parse(token.tokens);
          out += this.renderer.blockquote(body);
          continue;
        }
        case "list": {
          ordered = token.ordered;
          start = token.start;
          loose = token.loose;
          l2 = token.items.length;
          body = "";
          for (j = 0; j < l2; j++) {
            item = token.items[j];
            checked = item.checked;
            task = item.task;
            itemBody = "";
            if (item.task) {
              checkbox = this.renderer.checkbox(checked);
              if (loose) {
                if (item.tokens.length > 0 && item.tokens[0].type === "paragraph") {
                  item.tokens[0].text = checkbox + " " + item.tokens[0].text;
                  if (item.tokens[0].tokens && item.tokens[0].tokens.length > 0 && item.tokens[0].tokens[0].type === "text") {
                    item.tokens[0].tokens[0].text = checkbox + " " + item.tokens[0].tokens[0].text;
                  }
                } else {
                  item.tokens.unshift({
                    type: "text",
                    text: checkbox
                  });
                }
              } else {
                itemBody += checkbox;
              }
            }
            itemBody += this.parse(item.tokens, loose);
            body += this.renderer.listitem(itemBody, task, checked);
          }
          out += this.renderer.list(body, ordered, start);
          continue;
        }
        case "html": {
          out += this.renderer.html(token.text);
          continue;
        }
        case "paragraph": {
          out += this.renderer.paragraph(this.parseInline(token.tokens));
          continue;
        }
        case "text": {
          body = token.tokens ? this.parseInline(token.tokens) : token.text;
          while (i + 1 < l && tokens[i + 1].type === "text") {
            token = tokens[++i];
            body += "\n" + (token.tokens ? this.parseInline(token.tokens) : token.text);
          }
          out += top ? this.renderer.paragraph(body) : body;
          continue;
        }
        default: {
          const errMsg = 'Token with "' + token.type + '" type was not found.';
          if (this.options.silent) {
            console.error(errMsg);
            return;
          } else {
            throw new Error(errMsg);
          }
        }
      }
    }
    return out;
  }
  /**
   * Parse Inline Tokens
   */
  parseInline(tokens, renderer) {
    renderer = renderer || this.renderer;
    let out = "", i, token, ret;
    const l = tokens.length;
    for (i = 0; i < l; i++) {
      token = tokens[i];
      if (this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[token.type]) {
        ret = this.options.extensions.renderers[token.type].call({ parser: this }, token);
        if (ret !== false || !["escape", "html", "link", "image", "strong", "em", "codespan", "br", "del", "text"].includes(token.type)) {
          out += ret || "";
          continue;
        }
      }
      switch (token.type) {
        case "escape": {
          out += renderer.text(token.text);
          break;
        }
        case "html": {
          out += renderer.html(token.text);
          break;
        }
        case "link": {
          out += renderer.link(token.href, token.title, this.parseInline(token.tokens, renderer));
          break;
        }
        case "image": {
          out += renderer.image(token.href, token.title, token.text);
          break;
        }
        case "strong": {
          out += renderer.strong(this.parseInline(token.tokens, renderer));
          break;
        }
        case "em": {
          out += renderer.em(this.parseInline(token.tokens, renderer));
          break;
        }
        case "codespan": {
          out += renderer.codespan(token.text);
          break;
        }
        case "br": {
          out += renderer.br();
          break;
        }
        case "del": {
          out += renderer.del(this.parseInline(token.tokens, renderer));
          break;
        }
        case "text": {
          out += renderer.text(token.text);
          break;
        }
        default: {
          const errMsg = 'Token with "' + token.type + '" type was not found.';
          if (this.options.silent) {
            console.error(errMsg);
            return;
          } else {
            throw new Error(errMsg);
          }
        }
      }
    }
    return out;
  }
};
var Hooks = class {
  constructor(options2) {
    this.options = options2 || defaults;
  }
  /**
   * Process markdown before marked
   */
  preprocess(markdown) {
    return markdown;
  }
  /**
   * Process HTML after marked is finished
   */
  postprocess(html) {
    return html;
  }
};
__publicField(Hooks, "passThroughHooks", /* @__PURE__ */ new Set([
  "preprocess",
  "postprocess"
]));
function onError(silent, async, callback) {
  return (e) => {
    e.message += "\nPlease report this to https://github.com/markedjs/marked.";
    if (silent) {
      const msg = "<p>An error occurred:</p><pre>" + escape(e.message + "", true) + "</pre>";
      if (async) {
        return Promise.resolve(msg);
      }
      if (callback) {
        callback(null, msg);
        return;
      }
      return msg;
    }
    if (async) {
      return Promise.reject(e);
    }
    if (callback) {
      callback(e);
      return;
    }
    throw e;
  };
}
function parseMarkdown(lexer2, parser2) {
  return (src, opt, callback) => {
    if (typeof opt === "function") {
      callback = opt;
      opt = null;
    }
    const origOpt = { ...opt };
    opt = { ...marked.defaults, ...origOpt };
    const throwError = onError(opt.silent, opt.async, callback);
    if (typeof src === "undefined" || src === null) {
      return throwError(new Error("marked(): input parameter is undefined or null"));
    }
    if (typeof src !== "string") {
      return throwError(new Error("marked(): input parameter is of type " + Object.prototype.toString.call(src) + ", string expected"));
    }
    checkSanitizeDeprecation(opt);
    if (opt.hooks) {
      opt.hooks.options = opt;
    }
    if (callback) {
      const highlight = opt.highlight;
      let tokens;
      try {
        if (opt.hooks) {
          src = opt.hooks.preprocess(src);
        }
        tokens = lexer2(src, opt);
      } catch (e) {
        return throwError(e);
      }
      const done = function(err) {
        let out;
        if (!err) {
          try {
            if (opt.walkTokens) {
              marked.walkTokens(tokens, opt.walkTokens);
            }
            out = parser2(tokens, opt);
            if (opt.hooks) {
              out = opt.hooks.postprocess(out);
            }
          } catch (e) {
            err = e;
          }
        }
        opt.highlight = highlight;
        return err ? throwError(err) : callback(null, out);
      };
      if (!highlight || highlight.length < 3) {
        return done();
      }
      delete opt.highlight;
      if (!tokens.length)
        return done();
      let pending = 0;
      marked.walkTokens(tokens, function(token) {
        if (token.type === "code") {
          pending++;
          setTimeout(() => {
            highlight(token.text, token.lang, function(err, code) {
              if (err) {
                return done(err);
              }
              if (code != null && code !== token.text) {
                token.text = code;
                token.escaped = true;
              }
              pending--;
              if (pending === 0) {
                done();
              }
            });
          }, 0);
        }
      });
      if (pending === 0) {
        done();
      }
      return;
    }
    if (opt.async) {
      return Promise.resolve(opt.hooks ? opt.hooks.preprocess(src) : src).then((src2) => lexer2(src2, opt)).then((tokens) => opt.walkTokens ? Promise.all(marked.walkTokens(tokens, opt.walkTokens)).then(() => tokens) : tokens).then((tokens) => parser2(tokens, opt)).then((html) => opt.hooks ? opt.hooks.postprocess(html) : html).catch(throwError);
    }
    try {
      if (opt.hooks) {
        src = opt.hooks.preprocess(src);
      }
      const tokens = lexer2(src, opt);
      if (opt.walkTokens) {
        marked.walkTokens(tokens, opt.walkTokens);
      }
      let html = parser2(tokens, opt);
      if (opt.hooks) {
        html = opt.hooks.postprocess(html);
      }
      return html;
    } catch (e) {
      return throwError(e);
    }
  };
}
function marked(src, opt, callback) {
  return parseMarkdown(Lexer.lex, Parser.parse)(src, opt, callback);
}
marked.options = marked.setOptions = function(opt) {
  marked.defaults = { ...marked.defaults, ...opt };
  changeDefaults(marked.defaults);
  return marked;
};
marked.getDefaults = getDefaults;
marked.defaults = defaults;
marked.use = function(...args) {
  const extensions = marked.defaults.extensions || { renderers: {}, childTokens: {} };
  args.forEach((pack) => {
    const opts = { ...pack };
    opts.async = marked.defaults.async || opts.async || false;
    if (pack.extensions) {
      pack.extensions.forEach((ext) => {
        if (!ext.name) {
          throw new Error("extension name required");
        }
        if (ext.renderer) {
          const prevRenderer = extensions.renderers[ext.name];
          if (prevRenderer) {
            extensions.renderers[ext.name] = function(...args2) {
              let ret = ext.renderer.apply(this, args2);
              if (ret === false) {
                ret = prevRenderer.apply(this, args2);
              }
              return ret;
            };
          } else {
            extensions.renderers[ext.name] = ext.renderer;
          }
        }
        if (ext.tokenizer) {
          if (!ext.level || ext.level !== "block" && ext.level !== "inline") {
            throw new Error("extension level must be 'block' or 'inline'");
          }
          if (extensions[ext.level]) {
            extensions[ext.level].unshift(ext.tokenizer);
          } else {
            extensions[ext.level] = [ext.tokenizer];
          }
          if (ext.start) {
            if (ext.level === "block") {
              if (extensions.startBlock) {
                extensions.startBlock.push(ext.start);
              } else {
                extensions.startBlock = [ext.start];
              }
            } else if (ext.level === "inline") {
              if (extensions.startInline) {
                extensions.startInline.push(ext.start);
              } else {
                extensions.startInline = [ext.start];
              }
            }
          }
        }
        if (ext.childTokens) {
          extensions.childTokens[ext.name] = ext.childTokens;
        }
      });
      opts.extensions = extensions;
    }
    if (pack.renderer) {
      const renderer = marked.defaults.renderer || new Renderer();
      for (const prop in pack.renderer) {
        const prevRenderer = renderer[prop];
        renderer[prop] = (...args2) => {
          let ret = pack.renderer[prop].apply(renderer, args2);
          if (ret === false) {
            ret = prevRenderer.apply(renderer, args2);
          }
          return ret;
        };
      }
      opts.renderer = renderer;
    }
    if (pack.tokenizer) {
      const tokenizer = marked.defaults.tokenizer || new Tokenizer();
      for (const prop in pack.tokenizer) {
        const prevTokenizer = tokenizer[prop];
        tokenizer[prop] = (...args2) => {
          let ret = pack.tokenizer[prop].apply(tokenizer, args2);
          if (ret === false) {
            ret = prevTokenizer.apply(tokenizer, args2);
          }
          return ret;
        };
      }
      opts.tokenizer = tokenizer;
    }
    if (pack.hooks) {
      const hooks = marked.defaults.hooks || new Hooks();
      for (const prop in pack.hooks) {
        const prevHook = hooks[prop];
        if (Hooks.passThroughHooks.has(prop)) {
          hooks[prop] = (arg) => {
            if (marked.defaults.async) {
              return Promise.resolve(pack.hooks[prop].call(hooks, arg)).then((ret2) => {
                return prevHook.call(hooks, ret2);
              });
            }
            const ret = pack.hooks[prop].call(hooks, arg);
            return prevHook.call(hooks, ret);
          };
        } else {
          hooks[prop] = (...args2) => {
            let ret = pack.hooks[prop].apply(hooks, args2);
            if (ret === false) {
              ret = prevHook.apply(hooks, args2);
            }
            return ret;
          };
        }
      }
      opts.hooks = hooks;
    }
    if (pack.walkTokens) {
      const walkTokens2 = marked.defaults.walkTokens;
      opts.walkTokens = function(token) {
        let values = [];
        values.push(pack.walkTokens.call(this, token));
        if (walkTokens2) {
          values = values.concat(walkTokens2.call(this, token));
        }
        return values;
      };
    }
    marked.setOptions(opts);
  });
};
marked.walkTokens = function(tokens, callback) {
  let values = [];
  for (const token of tokens) {
    values = values.concat(callback.call(marked, token));
    switch (token.type) {
      case "table": {
        for (const cell of token.header) {
          values = values.concat(marked.walkTokens(cell.tokens, callback));
        }
        for (const row of token.rows) {
          for (const cell of row) {
            values = values.concat(marked.walkTokens(cell.tokens, callback));
          }
        }
        break;
      }
      case "list": {
        values = values.concat(marked.walkTokens(token.items, callback));
        break;
      }
      default: {
        if (marked.defaults.extensions && marked.defaults.extensions.childTokens && marked.defaults.extensions.childTokens[token.type]) {
          marked.defaults.extensions.childTokens[token.type].forEach(function(childTokens) {
            values = values.concat(marked.walkTokens(token[childTokens], callback));
          });
        } else if (token.tokens) {
          values = values.concat(marked.walkTokens(token.tokens, callback));
        }
      }
    }
  }
  return values;
};
marked.parseInline = parseMarkdown(Lexer.lexInline, Parser.parseInline);
marked.Parser = Parser;
marked.parser = Parser.parse;
marked.Renderer = Renderer;
marked.TextRenderer = TextRenderer;
marked.Lexer = Lexer;
marked.lexer = Lexer.lex;
marked.Tokenizer = Tokenizer;
marked.Slugger = Slugger;
marked.Hooks = Hooks;
marked.parse = marked;
var options = marked.options;
var setOptions = marked.setOptions;
var use = marked.use;
var walkTokens = marked.walkTokens;
var parseInline = marked.parseInline;
var parser = Parser.parse;
var lexer = Lexer.lex;

// src/components/PrismaHighlighting.ts
var import_obsidian = require("obsidian");
function prismHighlighting(messageBlock) {
  (0, import_obsidian.loadPrism)().then((Prism) => {
    const codeBlocks = messageBlock == null ? void 0 : messageBlock.querySelectorAll(".messageBlock pre code");
    codeBlocks == null ? void 0 : codeBlocks.forEach((codeBlock) => {
      const language = codeBlock.className.replace("language-", "");
      const code = codeBlock.textContent;
      if (language && Prism.languages[language]) {
        const highlightedCode = Prism.highlight(code, Prism.languages[language]);
        codeBlock.innerHTML = highlightedCode;
      }
    });
  });
}

// src/components/chat/Buttons.ts
var import_obsidian2 = require("obsidian");
function regenerateUserButton(settings, referenceCurrentNote) {
  const regenerateButton = document.createElement("button");
  regenerateButton.textContent = "regenerate";
  (0, import_obsidian2.setIcon)(regenerateButton, "refresh-ccw");
  regenerateButton.classList.add("regenerate-button");
  regenerateButton.title = "regenerate";
  regenerateButton.addEventListener("click", async function() {
    const messageContainerEl = document.querySelector("#messageContainer");
    if (messageContainerEl) {
      const botMessages = messageContainerEl.querySelectorAll(".botMessage");
      const lastBotMessage = botMessages[botMessages.length - 1];
      const messageBlock = lastBotMessage.querySelector(".messageBlock");
      const lastBotMessageToolBarDiv = lastBotMessage.querySelector(".botMessageToolBar");
      if (lastBotMessageToolBarDiv) {
        const buttonContainerDiv = lastBotMessageToolBarDiv.querySelector(".button-container");
        if (buttonContainerDiv) {
          buttonContainerDiv.remove();
        }
      }
      if (messageBlock) {
        messageBlock.innerHTML = "";
        messageHistory.pop();
        const loadingEl = document.createElement("span");
        loadingEl.setAttribute("id", "loading");
        loadingEl.style.display = "inline-block";
        loadingEl.textContent = "...";
        const updateLoadingAnimation = () => {
          var _a2;
          const loadingEl2 = document.querySelector("#loading");
          if (!loadingEl2) {
            return;
          }
          loadingEl2.textContent += ".";
          if (((_a2 = loadingEl2.textContent) == null ? void 0 : _a2.length) && loadingEl2.textContent.length > 3) {
            loadingEl2.textContent = ".";
          }
        };
        lastBotMessage.appendChild(loadingEl);
        loadingEl.scrollIntoView({ behavior: "smooth", block: "end" });
        const loadingAnimationIntervalId = setInterval(updateLoadingAnimation, 500);
        lastBotMessage.scrollIntoView({ behavior: "smooth", block: "end" });
        if (OPENAI_MODELS.includes(settings.model)) {
          try {
            await fetchOpenAIAPI(settings, referenceCurrentNote);
          } catch (error) {
            new import_obsidian2.Notice("Error occurred while fetching completion: " + error.message);
            console.log(error.message);
          }
        } else if (settings.openAIBaseModels.includes(settings.model)) {
          try {
            await fetchOpenAIBaseAPI(settings, referenceCurrentNote);
          } catch (error) {
            new import_obsidian2.Notice("Error occurred while fetching completion: " + error.message);
            console.log(error.message);
          }
        } else if (settings.ollamaRestAPIUrl) {
          if (settings.allowOllamaStream) {
            await ollamaFetchDataStream(settings, referenceCurrentNote);
          } else {
            await ollamaFetchData(settings, referenceCurrentNote);
          }
        } else if (ANTHROPIC_MODELS.includes(settings.model)) {
          try {
            await requestUrlAnthropicAPI(settings, referenceCurrentNote);
          } catch (error) {
            console.error("Error:", error);
          }
        } else if (settings.localAIRestAPIUrl) {
          await requestUrlChatCompletion(settings, referenceCurrentNote);
        } else {
          new import_obsidian2.Notice("No models detected.");
        }
        clearInterval(loadingAnimationIntervalId);
      }
    }
  });
  return regenerateButton;
}
function displayUserCopyButton(userP) {
  const copyButton = document.createElement("button");
  copyButton.textContent = "copy";
  (0, import_obsidian2.setIcon)(copyButton, "copy");
  copyButton.classList.add("copy-button");
  copyButton.title = "copy";
  copyButton.addEventListener("click", function() {
    const messageText = userP.textContent;
    if (messageText !== null) {
      copyMessageToClipboard(messageText);
      new import_obsidian2.Notice("Copied user message.");
    } else {
      console.error("Message content is null. Cannot copy.");
    }
  });
  return copyButton;
}
function displayBotCopyButton(messageObj, settings) {
  const copyButton = document.createElement("button");
  copyButton.textContent = "copy";
  (0, import_obsidian2.setIcon)(copyButton, "copy");
  copyButton.classList.add("copy-button");
  copyButton.title = "copy";
  let messageText = messageObj.content;
  if (messageText !== null) {
    if (ANTHROPIC_MODELS.includes(settings.model)) {
      const fullString = messageObj.content;
      const cleanString = fullString.split(" ").slice(1).join(" ").trim();
      messageText = cleanString;
    }
  } else {
    new import_obsidian2.Notice("Message content is null. Cannot copy.");
    console.error("Message content is null. Cannot copy.");
  }
  copyButton.addEventListener("click", function() {
    if (messageText !== null) {
      copyMessageToClipboard(messageText);
      new import_obsidian2.Notice("Copied bot message.");
    } else {
      console.error("Message content is null. Cannot copy.");
    }
  });
  return copyButton;
}
function codeBlockCopyButton(messageBlock) {
  const codeBlocks = messageBlock.querySelectorAll(".messageBlock pre code");
  codeBlocks.forEach((codeElement) => {
    const copyButton = document.createElement("button");
    copyButton.textContent = "copy";
    (0, import_obsidian2.setIcon)(copyButton, "copy");
    copyButton.classList.add("copy-button");
    copyButton.title = "copy";
    if (codeElement.parentNode) {
      codeElement.parentNode.insertBefore(copyButton, codeElement.nextSibling);
    }
    copyButton.addEventListener("click", () => {
      var _a2;
      const language = ((_a2 = codeElement.getAttribute("class")) == null ? void 0 : _a2.replace("language-", "")) || "";
      const codeText = `\`\`\`${language}
${codeElement.textContent}\`\`\``;
      if (codeText) {
        navigator.clipboard.writeText(codeText).then(() => {
          new import_obsidian2.Notice("Copied codeblock.");
        }, (err) => {
          console.error("Failed to copy code: ", err);
          new import_obsidian2.Notice("Failed to copy code: ", err);
        });
      }
    });
  });
}
function copyMessageToClipboard(message) {
  navigator.clipboard.writeText(message).then(function() {
  }).catch(function(err) {
    console.error("Unable to copy message: ", err);
  });
}
function displayAppendButton(messageObj) {
  const appendButton = document.createElement("button");
  appendButton.textContent = "append";
  (0, import_obsidian2.setIcon)(appendButton, "plus-square");
  appendButton.classList.add("append-button");
  appendButton.title = "append";
  const messageText = messageObj.content;
  appendButton.addEventListener("click", async function(event) {
    var _a2, _b;
    if (((_a2 = checkActiveFile) == null ? void 0 : _a2.extension) === "md") {
      if (checkActiveFile !== lastCursorPositionFile) {
        const existingContent = await app.vault.read(checkActiveFile);
        const updatedContent = existingContent + "\n" + messageText;
        app.vault.modify(checkActiveFile, updatedContent);
      } else {
        (_b = activeEditor) == null ? void 0 : _b.replaceRange(messageText, lastCursorPosition);
      }
      event.stopPropagation();
      new import_obsidian2.Notice("Appended response.");
    } else {
      new import_obsidian2.Notice("No active Markdown file detected.");
    }
  });
  return appendButton;
}
function displayTrashButton() {
  const trashButton = document.createElement("button");
  trashButton.textContent = "trash";
  (0, import_obsidian2.setIcon)(trashButton, "trash");
  trashButton.classList.add("trash-button");
  trashButton.title = "trash";
  let lastClickedElement = null;
  trashButton.addEventListener("click", function(event) {
    event.stopPropagation();
    lastClickedElement = event.target;
    while (lastClickedElement && !lastClickedElement.classList.contains("userMessage")) {
      lastClickedElement = lastClickedElement.parentElement;
    }
    if (lastClickedElement) {
      const userMessages = Array.from(document.querySelectorAll("#messageContainer .userMessage"));
      const index = userMessages.indexOf(lastClickedElement) * 2;
      if (index !== -1) {
        const modal = new import_obsidian2.Modal(app);
        modal.contentEl.innerHTML = `
                <div class="modal-content">
                    <h2>Delete Message Block.</h2>
                    <p>Are you sure you want to delete this message block?</p>
                    <button id="confirmDelete">Confirm Delete</button>
                </div>
                `;
        const confirmDeleteButton = modal.contentEl.querySelector("#confirmDelete");
        confirmDeleteButton == null ? void 0 : confirmDeleteButton.addEventListener("click", async function() {
          deleteMessage(index);
          new import_obsidian2.Notice("Message deleted.");
          modal.close();
        });
        modal.open();
      }
    }
  });
  return trashButton;
}
async function deleteMessage(index) {
  const messageContainer = document.querySelector("#messageContainer");
  const divElements = messageContainer == null ? void 0 : messageContainer.querySelectorAll("div.botMessage, div.userMessage");
  if (divElements && divElements.length > 0 && index >= 0 && index < divElements.length) {
    messageContainer == null ? void 0 : messageContainer.removeChild(divElements[index]);
    if (index + 1 < divElements.length) {
      const nextMessage = divElements[index + 1];
      if (nextMessage.classList.contains("botMessage")) {
        messageContainer == null ? void 0 : messageContainer.removeChild(nextMessage);
      }
    }
  }
  if (messageHistory[index + 1] && messageHistory[index + 1].role === "assistant") {
    messageHistory.splice(index, 2);
  } else {
    messageHistory.splice(index, 1);
  }
  const jsonString = JSON.stringify(messageHistory, null, 4);
  try {
    await app.vault.adapter.write(filenameMessageHistoryJSON, jsonString);
  } catch (error) {
    console.error("Error writing messageHistory.json", error);
  }
}

// src/components/chat/Message.ts
async function addMessage(input, messageType, settings) {
  const messageObj = {
    role: "",
    content: ""
  };
  if (messageType === "userMessage") {
    messageObj.role = "user";
    messageObj.content = input;
  } else if (messageType === "botMessage") {
    messageObj.role = "assistant";
    messageObj.content = input.trim();
    const botMessageToolBarDiv = document.querySelectorAll(".botMessageToolBar");
    const lastBotMessageToolBarDiv = botMessageToolBarDiv[botMessageToolBarDiv.length - 1];
    if (botMessageToolBarDiv.length > 0) {
      if (!messageObj.content.includes('div class="formattedSettings"')) {
        const buttonContainerDiv = document.createElement("div");
        const copyBotButton = displayBotCopyButton(messageObj, settings);
        const appendButton = displayAppendButton(messageObj);
        buttonContainerDiv.className = "button-container";
        lastBotMessageToolBarDiv.appendChild(buttonContainerDiv);
        buttonContainerDiv.appendChild(copyBotButton);
        buttonContainerDiv.appendChild(appendButton);
      }
    }
  }
  messageHistory.push(messageObj);
  const jsonString = JSON.stringify(messageHistory, null, 4);
  try {
    await this.app.vault.adapter.write(filenameMessageHistoryJSON, jsonString);
  } catch (error) {
    console.error("Error writing to message history file:", error);
  }
}
function addParagraphBreaks(messageBlock) {
  const paragraphs = messageBlock.querySelectorAll("p");
  for (let i = 0; i < paragraphs.length; i++) {
    const p = paragraphs[i];
    const nextSibling = p.nextElementSibling;
    if (nextSibling && nextSibling.nodeName === "P") {
      const br = document.createElement("br");
      const parent = p.parentNode;
      if (parent) {
        parent.insertBefore(br, nextSibling);
      }
    }
  }
}

// src/components/chat/Prompt.ts
async function getPrompt(settings) {
  if (!settings.prompt || settings.prompt.trim() === "") {
    return "";
  }
  const promptFilePath = settings.promptFolderPath + settings.prompt;
  try {
    const content = await app.vault.adapter.read(promptFilePath);
    const cleanedContent = content.replace(/---[\s\S]+?---/, "").trim();
    return cleanedContent;
  } catch (error) {
    console.error(`Error reading file ${promptFilePath}:`, error);
    return null;
  }
}

// src/components/FetchModel.ts
var abortController = new AbortController();
async function fetchOpenAIAPI(settings, referenceCurrentNote) {
  var _a2, _b, _c, _d, _e, _f;
  const openai = new openai_default({
    apiKey: settings.apiKey,
    baseURL: settings.openAIBaseUrl,
    dangerouslyAllowBrowser: true
    // apiKey is stored within data.json
  });
  abortController = new AbortController();
  let message = "";
  let isScroll = false;
  const prompt = await getPrompt(settings);
  const filteredMessageHistoryContent = messageHistory.filter((message2, index, array) => {
    var _a3, _b2;
    const isUserMessageWithSlash = message2.role === "user" && message2.content.includes("/") || ((_a3 = array[index - 1]) == null ? void 0 : _a3.role) === "user" && ((_b2 = array[index - 1]) == null ? void 0 : _b2.content.includes("/"));
    return !isUserMessageWithSlash;
  });
  try {
    const stream = await openai.chat.completions.create({
      model: settings.model,
      max_tokens: parseInt(settings.max_tokens),
      temperature: settings.temperature,
      messages: [
        { role: "system", content: referenceCurrentNote + settings.system_role + prompt },
        ...filteredMessageHistoryContent
      ],
      stream: true
    });
    for await (const part of stream) {
      const content = ((_b = (_a2 = part.choices[0]) == null ? void 0 : _a2.delta) == null ? void 0 : _b.content) || "";
      message += content;
      const messageContainerEl = document.querySelector("#messageContainer");
      if (messageContainerEl) {
        const botMessages = messageContainerEl.querySelectorAll(".botMessage");
        const lastBotMessage = botMessages[botMessages.length - 1];
        const messageBlock = lastBotMessage.querySelector(".messageBlock");
        const loadingEl = lastBotMessage.querySelector("#loading");
        if (messageBlock) {
          if (loadingEl) {
            loadingEl.scrollIntoView({ behavior: "smooth", block: "end" });
            lastBotMessage.removeChild(loadingEl);
          }
          messageBlock.innerHTML = marked(message);
          addParagraphBreaks(messageBlock);
          prismHighlighting(messageBlock);
          codeBlockCopyButton(messageBlock);
        }
        messageContainerEl.addEventListener("wheel", (event) => {
          if (event.deltaY < 0 || event.deltaY > 0) {
            isScroll = true;
          }
        });
        if (!isScroll) {
          lastBotMessage.scrollIntoView({ behavior: "auto", block: "start" });
        }
      }
      if (abortController.signal.aborted) {
        new import_obsidian3.Notice("Error making API request: The user aborted a request.");
        break;
      }
    }
    addMessage(message, "botMessage", settings);
  } catch (error) {
    const messageContainerEl = document.querySelector("#messageContainer");
    if (messageContainerEl) {
      const botMessages = messageContainerEl.querySelectorAll(".botMessage");
      const lastBotMessage = botMessages[botMessages.length - 1];
      const messageBlock = lastBotMessage.querySelector(".messageBlock");
      if (messageBlock) {
        messageBlock.innerHTML = marked(((_d = (_c = error.response) == null ? void 0 : _c.data) == null ? void 0 : _d.error) || error.message);
        addMessage(messageBlock.innerHTML, "botMessage", settings);
      }
    }
    throw new Error(((_f = (_e = error.response) == null ? void 0 : _e.data) == null ? void 0 : _f.error) || error.message);
  }
}
async function fetchOpenAIAPIEditor(settings, selectionString) {
  const openai = new openai_default({
    apiKey: settings.apiKey,
    baseURL: settings.openAIBaseUrl,
    dangerouslyAllowBrowser: true
    // apiKey is stored within data.json
  });
  const completion = await openai.chat.completions.create({
    model: settings.model,
    max_tokens: parseInt(settings.max_tokens),
    messages: [
      { role: "system", content: settings.system_role },
      { role: "user", content: selectionString }
    ]
  });
  const message = completion.choices[0].message.content;
  return message;
}
async function fetchOpenAIBaseAPI(settings, referenceCurrentNote) {
  const openai = new openai_default({
    apiKey: settings.apiKey,
    baseURL: settings.openAIBaseUrl,
    dangerouslyAllowBrowser: true
    // apiKey is stored within data.json
  });
  const prompt = await getPrompt(settings);
  const filteredMessageHistoryContent = messageHistory.filter((message, index, array) => {
    var _a2, _b;
    const isUserMessageWithSlash = message.role === "user" && message.content.includes("/") || ((_a2 = array[index - 1]) == null ? void 0 : _a2.role) === "user" && ((_b = array[index - 1]) == null ? void 0 : _b.content.includes("/"));
    return !isUserMessageWithSlash;
  });
  try {
    const completion = await openai.chat.completions.create({
      model: settings.model,
      max_tokens: parseInt(settings.max_tokens),
      messages: [
        { role: "system", content: referenceCurrentNote + settings.system_role + prompt },
        ...filteredMessageHistoryContent
      ]
    });
    const message = completion.choices[0].message.content;
    const messageContainerEl = document.querySelector("#messageContainer");
    if (messageContainerEl) {
      const botMessages = messageContainerEl.querySelectorAll(".botMessage");
      const lastBotMessage = botMessages[botMessages.length - 1];
      const messageBlock = lastBotMessage.querySelector(".messageBlock");
      const loadingEl = lastBotMessage.querySelector("#loading");
      if (messageBlock) {
        if (loadingEl) {
          loadingEl.scrollIntoView({ behavior: "smooth", block: "end" });
          lastBotMessage.removeChild(loadingEl);
        }
        messageBlock.innerHTML = marked(message || "", { breaks: true });
        addParagraphBreaks(messageBlock);
        prismHighlighting(messageBlock);
        codeBlockCopyButton(messageBlock);
        lastBotMessage.appendChild(messageBlock);
      }
      lastBotMessage.scrollIntoView({ behavior: "smooth", block: "start" });
    }
    if (message != null) {
      addMessage(message, "botMessage", settings);
    }
  } catch (error) {
    console.error("Error making API request:", error);
    throw error;
  }
}
async function fetchOpenAIBaseAPIEditor(settings, selectionString) {
  const openai = new openai_default({
    apiKey: settings.apiKey,
    baseURL: settings.openAIBaseUrl,
    dangerouslyAllowBrowser: true
    // apiKey is stored within data.json
  });
  const completion = await openai.chat.completions.create({
    model: settings.model,
    max_tokens: parseInt(settings.max_tokens),
    messages: [
      { role: "system", content: settings.system_role },
      { role: "user", content: selectionString }
    ]
  });
  const message = completion.choices[0].message.content;
  return message;
}
async function ollamaFetchData(settings, referenceCurrentNoteContent2) {
  const ollamaRestAPIUrl = settings.ollamaRestAPIUrl;
  if (!ollamaRestAPIUrl) {
    return;
  }
  const prompt = await getPrompt(settings);
  try {
    const response = await (0, import_obsidian3.requestUrl)({
      url: ollamaRestAPIUrl + "/api/chat",
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify({
        model: settings.model,
        messages: [
          { role: "system", content: referenceCurrentNoteContent2 + settings.system_role + prompt },
          ...messageHistory
        ],
        stream: false,
        options: {
          temperature: settings.temperature,
          num_predict: parseInt(settings.max_tokens)
        }
      })
    });
    const message = response.json.message.content;
    const messageContainerEl = document.querySelector("#messageContainer");
    if (messageContainerEl) {
      const botMessages = messageContainerEl.querySelectorAll(".botMessage");
      const lastBotMessage = botMessages[botMessages.length - 1];
      const messageBlock = lastBotMessage.querySelector(".messageBlock");
      const loadingEl = lastBotMessage.querySelector("#loading");
      if (messageBlock) {
        if (loadingEl) {
          loadingEl.scrollIntoView({ behavior: "smooth", block: "end" });
          lastBotMessage.removeChild(loadingEl);
        }
        messageBlock.innerHTML = marked(message, { breaks: true });
        addParagraphBreaks(messageBlock);
        prismHighlighting(messageBlock);
        codeBlockCopyButton(messageBlock);
        lastBotMessage.appendChild(messageBlock);
      }
      lastBotMessage.scrollIntoView({ behavior: "smooth", block: "start" });
    }
    addMessage(message, "botMessage", settings);
  } catch (error) {
    console.error("Error making API request:", error);
    throw error;
  }
}
async function ollamaFetchDataEditor(settings, selectionString) {
  const ollamaRestAPIUrl = settings.ollamaRestAPIUrl;
  if (!ollamaRestAPIUrl) {
    return;
  }
  try {
    const response = await (0, import_obsidian3.requestUrl)({
      url: ollamaRestAPIUrl + "/api/chat",
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify({
        model: settings.model,
        messages: [
          { role: "system", content: settings.system_role },
          { role: "user", content: selectionString }
        ],
        stream: false,
        options: {
          temperature: settings.temperature,
          num_predict: parseInt(settings.max_tokens)
        }
      })
    });
    const message = response.json.message.content;
    return message;
  } catch (error) {
    console.error("Error making API request:", error);
    throw error;
  }
}
async function ollamaFetchDataStream(settings, referenceCurrentNoteContent2) {
  const ollamaRestAPIUrl = settings.ollamaRestAPIUrl;
  if (!ollamaRestAPIUrl) {
    return;
  }
  const url = ollamaRestAPIUrl + "/api/chat";
  abortController = new AbortController();
  let message = "";
  let isScroll = false;
  const prompt = await getPrompt(settings);
  const filteredMessageHistoryContent = messageHistory.filter((message2, index, array) => {
    var _a2, _b;
    const isUserMessageWithSlash = message2.role === "user" && message2.content.includes("/") || ((_a2 = array[index - 1]) == null ? void 0 : _a2.role) === "user" && ((_b = array[index - 1]) == null ? void 0 : _b.content.includes("/"));
    return !isUserMessageWithSlash;
  });
  try {
    const response = await fetch(url, {
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify({
        model: settings.model,
        messages: [
          { role: "system", content: referenceCurrentNoteContent2 + settings.system_role + prompt },
          ...filteredMessageHistoryContent
        ],
        stream: true,
        options: {
          temperature: settings.temperature,
          num_predict: parseInt(settings.max_tokens)
        }
      }),
      signal: abortController.signal
    });
    if (!response.ok) {
      new import_obsidian3.Notice(`HTTP error! Status: ${response.status}`);
      throw new Error(`HTTP error! Status: ${response.status}`);
    }
    if (!response.body) {
      new import_obsidian3.Notice(`Response body is null or undefined.`);
      throw new Error("Response body is null or undefined.");
    }
    const reader = response.body.getReader();
    const decoder = new TextDecoder();
    let reading = true;
    while (reading) {
      const { done, value } = await reader.read();
      if (done) {
        reading = false;
        break;
      }
      const chunk = decoder.decode(value, { stream: true }) || "";
      const parts = chunk.split("\n");
      for (const part of parts.filter(Boolean)) {
        let parsedChunk;
        try {
          parsedChunk = JSON.parse(part);
          if (parsedChunk.done !== true) {
            const content = parsedChunk.message.content;
            message += content;
          }
        } catch (err) {
          console.error("Error parsing JSON:", err);
          console.log("Part with error:", part);
          parsedChunk = { response: "{_e_}" };
        }
      }
      const messageContainerEl = document.querySelector("#messageContainer");
      if (messageContainerEl) {
        const botMessages = messageContainerEl.querySelectorAll(".botMessage");
        const lastBotMessage = botMessages[botMessages.length - 1];
        const messageBlock = lastBotMessage.querySelector(".messageBlock");
        const loadingEl = lastBotMessage.querySelector("#loading");
        if (messageBlock) {
          if (loadingEl) {
            loadingEl.scrollIntoView({ behavior: "smooth", block: "end" });
            lastBotMessage.removeChild(loadingEl);
          }
          messageBlock.innerHTML = marked(message, { breaks: true });
          addParagraphBreaks(messageBlock);
          prismHighlighting(messageBlock);
          codeBlockCopyButton(messageBlock);
        }
        messageContainerEl.addEventListener("wheel", (event) => {
          if (event.deltaY < 0 || event.deltaY > 0) {
            isScroll = true;
          }
        });
        if (!isScroll) {
          lastBotMessage.scrollIntoView({ behavior: "auto", block: "start" });
        }
      }
    }
    addMessage(message, "botMessage", settings);
  } catch (error) {
    addMessage(message, "botMessage", settings);
    console.error("Error making API request:", error);
    throw error;
  }
}
async function requestUrlAnthropicAPI(settings, referenceCurrentNoteContent2) {
  const headers = {
    "anthropic-version": "2023-06-01",
    "content-type": "application/json",
    "x-api-key": settings.apiKey
  };
  const messageHistoryString = messageHistory.map((entry) => entry.content).join("\n");
  const prompt = await getPrompt(settings);
  const requestBody = {
    model: settings.model,
    prompt: `

Human: ${referenceCurrentNoteContent2}

${settings.system_role}

${prompt}

${messageHistoryString}

Assistant:`,
    max_tokens_to_sample: parseInt(settings.max_tokens) || 1e5,
    temperature: settings.temperature,
    stream: true
  };
  try {
    const response = await (0, import_obsidian3.requestUrl)({
      url: "https://api.anthropic.com/v1/complete",
      method: "POST",
      headers,
      body: JSON.stringify(requestBody)
    });
    const message = response.text;
    const lines = message.split("\n");
    let completionText = "";
    for (const line of lines) {
      if (line.startsWith("data:")) {
        const eventData = JSON.parse(line.slice("data:".length));
        if (eventData.completion) {
          completionText += eventData.completion;
        }
      }
    }
    const messageContainerEl = document.querySelector("#messageContainer");
    if (messageContainerEl) {
      const botMessages = messageContainerEl.querySelectorAll(".botMessage");
      const lastBotMessage = botMessages[botMessages.length - 1];
      const loadingEl = lastBotMessage.querySelector("#loading");
      if (loadingEl) {
        loadingEl.scrollIntoView({ behavior: "smooth", block: "end" });
        lastBotMessage.removeChild(loadingEl);
      }
      const messageBlock = lastBotMessage.querySelector(".messageBlock");
      if (messageBlock) {
        messageBlock.innerHTML = marked(completionText);
        addParagraphBreaks(messageBlock);
        prismHighlighting(messageBlock);
        codeBlockCopyButton(messageBlock);
      }
      lastBotMessage.scrollIntoView({ behavior: "smooth", block: "start" });
    }
    addMessage("\n\nAssistant: " + completionText, "botMessage", settings);
  } catch (error) {
    const messageContainerEl = document.querySelector("#messageContainer");
    if (messageContainerEl) {
      const botMessages = messageContainerEl.querySelectorAll(".botMessage");
      const lastBotMessage = botMessages[botMessages.length - 1];
      const messageBlock = lastBotMessage.querySelector(".messageBlock");
      if (messageBlock) {
        messageBlock.innerHTML = "Max tokens overflow. Please reduce max_tokens or clear chat messages. We recommend clearing max_tokens for best results.";
        addMessage(messageBlock.innerHTML, "botMessage", settings);
        const loadingEl = lastBotMessage.querySelector("#loading");
        if (loadingEl) {
          loadingEl.scrollIntoView({ behavior: "smooth", block: "end" });
          lastBotMessage.removeChild(loadingEl);
        }
      }
    }
    console.error("Error making API request:", error);
    throw error;
  }
}
async function requestUrlAnthropicAPIEditor(settings, selectionString) {
  const headers = {
    "anthropic-version": "2023-06-01",
    "content-type": "application/json",
    "x-api-key": settings.apiKey
  };
  const requestBody = {
    model: settings.model,
    prompt: `

Human: ${settings.system_role}

${selectionString}

Assistant:`,
    max_tokens_to_sample: parseInt(settings.max_tokens) || 1e5,
    temperature: settings.temperature,
    stream: false
  };
  try {
    const response = await (0, import_obsidian3.requestUrl)({
      url: "https://api.anthropic.com/v1/complete",
      method: "POST",
      headers,
      body: JSON.stringify(requestBody)
    });
    return response;
  } catch (error) {
    console.error("Error making API request:", error);
    throw error;
  }
}
async function requestUrlChatCompletion(settings, referenceCurrentNote) {
  const prompt = await getPrompt(settings);
  try {
    const response = await (0, import_obsidian3.requestUrl)({
      url: settings.localAIRestAPIUrl + "/v1/chat/completions",
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "Authorization": `Bearer ${settings.apiKey}`
      },
      body: JSON.stringify({
        model: settings.model,
        messages: [
          { role: "system", content: referenceCurrentNote + settings.system_role + prompt },
          ...messageHistory
        ],
        max_tokens: parseInt(settings.max_tokens),
        temperature: settings.temperature
      })
    });
    return response;
  } catch (error) {
    console.error("Error making API request:", error);
    throw error;
  }
}
async function fetchModelRenameTitle(settings, referenceCurrentNoteContent2) {
  var _a2, _b;
  const prompt = `You are a title generator. You will give succinct titles that does not contain backslashes,
                    forward slashes, or colons. Please generate one title as your response.

`;
  try {
    if (OPENAI_MODELS.includes(settings.model) || settings.openAIBaseModels.includes(settings.model)) {
      const openai = new openai_default({
        apiKey: settings.apiKey,
        baseURL: settings.openAIBaseUrl,
        dangerouslyAllowBrowser: true
        // apiKey is stored within data.json
      });
      const chatCompletion = await openai.chat.completions.create({
        model: settings.model,
        max_tokens: 40,
        messages: [
          { role: "system", content: prompt + referenceCurrentNoteContent2 }
        ]
      });
      let title = chatCompletion.choices[0].message.content;
      if (title) {
        title = title.replace(/[\\/:"]/g, "");
      }
      return title;
    } else if (ANTHROPIC_MODELS.includes(settings.model)) {
      const headers = {
        "anthropic-version": "2023-06-01",
        "content-type": "application/json",
        "x-api-key": settings.apiKey
      };
      const requestBody = {
        model: settings.model,
        prompt: `

Human: ${prompt}

Assistant:`,
        max_tokens_to_sample: 40,
        temperature: settings.temperature,
        stream: true
      };
      try {
        const response = await (0, import_obsidian3.requestUrl)({
          url: "https://api.anthropic.com/v1/complete",
          method: "POST",
          headers,
          body: JSON.stringify(requestBody)
        });
        const message = response.text;
        const lines = message.split("\n");
        let title = "";
        for (const line of lines) {
          if (line.startsWith("data:")) {
            const eventData = JSON.parse(line.slice("data:".length));
            if (eventData.completion) {
              title += eventData.completion;
            }
          }
        }
        if (title) {
          title = title.replace(/[\\/:"]/g, "");
        }
        return title;
      } catch (error) {
        new import_obsidian3.Notice("Error making API request:", error);
        console.error("Error making API request:", error);
        throw error;
      }
    } else {
      if (settings.ollamaRestAPIUrl) {
        const url = settings.ollamaRestAPIUrl + "/api/generate";
        const requestBody = {
          prompt: prompt + "\n\n" + referenceCurrentNoteContent2 + "\n\n",
          model: settings.model,
          stream: false,
          options: {
            temperature: settings.temperature,
            num_predict: 25
          }
        };
        const response = await (0, import_obsidian3.requestUrl)({
          url,
          method: "POST",
          headers: {
            "Content-Type": "application/json"
          },
          body: JSON.stringify(requestBody)
        });
        const parseText = JSON.parse(response.text);
        let title = parseText.response;
        if (title) {
          title = title.replace(/[\\/:"]/g, "");
        }
        return title;
      }
    }
  } catch (error) {
    console.log("ERROR");
    throw new Error(((_b = (_a2 = error.response) == null ? void 0 : _a2.data) == null ? void 0 : _b.error) || error.message);
  }
}
function getAbortController() {
  return abortController;
}

// src/components/chat/Commands.ts
var import_obsidian4 = require("obsidian");
function executeCommand(input, settings, plugin) {
  const command = input.split(" ")[0];
  switch (command) {
    case "/commands":
    case "/help":
      commandHelp(settings);
      break;
    case "/model":
    case "/models":
      return commandModel(input, settings, plugin);
    case "/prompt":
    case "/prompts":
      return commandPrompt(input, settings, plugin);
    case "/reference":
    case "/ref":
      commandReference(input, settings, plugin);
      break;
    case "/temp":
      commandTemperature(input, settings, plugin);
      break;
    case "/maxtokens":
      commandMaxTokens(input, settings, plugin);
      break;
    case "/system":
      commandSystem(input, settings, plugin);
      break;
    case "/append":
      commandAppend(settings);
      break;
    case "/save":
      commandSave(settings);
      break;
    case "/clear":
    case "/c":
      removeMessageThread(0);
      break;
    case "/stop":
    case "/s":
      commandStop();
      break;
    default:
      commandFalse(settings, plugin);
  }
}
function createBotMessage(currentSettings) {
  const messageContainer = document.querySelector("#messageContainer");
  const botMessage = document.createElement("div");
  botMessage.classList.add("botMessage");
  botMessage.style.backgroundColor = colorToHex(
    currentSettings.botMessageBackgroundColor || getComputedStyle(document.body).getPropertyValue(DEFAULT_SETTINGS.botMessageBackgroundColor).trim()
  );
  messageContainer == null ? void 0 : messageContainer.appendChild(botMessage);
  const botNameSpan = document.createElement("span");
  botNameSpan.textContent = currentSettings.chatbotName || DEFAULT_SETTINGS.chatbotName;
  botNameSpan.className = "chatbotName";
  botMessage.appendChild(botNameSpan);
  const messageBlock = document.createElement("div");
  messageBlock.classList.add("messageBlock");
  botMessage.appendChild(messageBlock);
  return messageBlock;
}
function displayMessage(messageBlock, messageHtml, currentSettings) {
  const messageContainer = document.querySelector("#messageContainer");
  if (messageContainer) {
    const botMessages = messageContainer.querySelectorAll(".botMessage");
    const lastBotMessage = botMessages[botMessages.length - 1];
    const messageBlock2 = lastBotMessage.querySelector(".messageBlock");
    if (messageBlock2) {
      messageBlock2.innerHTML = messageHtml;
      addMessage(messageBlock.innerHTML, "botMessage", currentSettings);
      lastBotMessage.appendChild(messageBlock2);
      lastBotMessage.scrollIntoView({ behavior: "smooth", block: "start" });
    }
  }
}
async function commandFalse(currentSettings, plugin) {
  const messageBlock = createBotMessage(currentSettings);
  const formattedSettings = `
      <div class="formattedSettings">
          <p><strong>Command not recognized.</strong></p>
      </div>
  `;
  displayMessage(messageBlock, formattedSettings, currentSettings);
  await plugin.saveSettings();
}
function commandHelp(currentSettings) {
  const messageBlock = createBotMessage(currentSettings);
  const formattedSettings = `
    <div class="formattedSettings">
      <h2>Commands</h2>
      <p><code>/model "[MODEL-NAME]" or [VALUE]</code> - List or change model.</p>
      <p><code>/prompt "[PROMPT-NAME]" or [VALUE]</code> - List or change prompt.</p>
      <p><code>/prompt clear</code> - Clear prompt.</p>
      <p><code>/system "[PROMPT]"</code> - Change system setting.</p>
      <p><code>/maxtokens [VALUE]</code> - Set max tokens.</p>
      <p><code>/temp [VALUE]</code> - Change temperature range 0 from to 1.</p>
      <p><code>/ref on | off</code> - Turn on or off "reference current note".</p>
      <p><code>/append</code> - Append current chat history to current active note.</p>
      <p><code>/save</code> - Save current chat history to a note.</p>
      <p><code>/clear</code> or <code>/c</code> - Clear chat history.</p>
      <p><code>/stop</code> or <code>/s</code> - [STREAMING MODELS ONLY]: Stop fetching response.</p>
    </div>
  `;
  displayMessage(messageBlock, formattedSettings, currentSettings);
}
async function commandModel(input, currentSettings, plugin) {
  const messageBlock = createBotMessage(currentSettings);
  if (!input.split(" ")[1]) {
    const modelListItems = currentSettings.allModels.map((model) => `<li>${model}</li>`).join("");
    const formattedSettings = `<div class="formattedSettings">
    <h2>Models</h2>
      <ol>${modelListItems}</ol>
    </div>`;
    displayMessage(messageBlock, formattedSettings, currentSettings);
  }
  if (input.split(" ")[1] !== void 0) {
    const inputModel = input.split(" ")[1].replace(/^"(.*)"$/, "$1");
    let messageHtml = "";
    const modelAliases = {};
    for (let i = 1; i <= currentSettings.allModels.length; i++) {
      const model = currentSettings.allModels[i - 1];
      modelAliases[i] = model;
    }
    if (Object.entries(modelAliases).find(([key, val]) => key === inputModel)) {
      currentSettings.model = modelAliases[inputModel];
      messageHtml = `<div class="formattedSettings"><p><strong>Updated Model to ${currentSettings.model}</strong></p></div>`;
    } else if (Object.entries(modelAliases).find(([key, val]) => val === inputModel)) {
      currentSettings.model = modelAliases[Object.keys(modelAliases).find((key) => modelAliases[key] === inputModel) || ""];
      messageHtml = `<div class="formattedSettings"><p><strong>Updated Model to ${currentSettings.model}</strong></p></div>`;
    } else {
      messageHtml = `<div class="formattedSettings"><p><strong>Model '${inputModel}' does not exist for this API key.</strong></p></div>`;
      new import_obsidian4.Notice("Invalid model.");
    }
    displayMessage(messageBlock, messageHtml, currentSettings);
    await plugin.saveSettings();
    return currentSettings;
  }
}
async function commandPrompt(input, currentSettings, plugin) {
  const files = app.vault.getFiles().filter((file) => file.path.startsWith(plugin.settings.promptFolderPath));
  const messageBlock = createBotMessage(currentSettings);
  files.sort((a, b) => a.name.localeCompare(b.name));
  if (!input.split(" ")[1]) {
    const fileListItems = files.map((file) => {
      const fileNameWithoutExtension = file.name.replace(/\.[^/.]+$/, "");
      return `<li>${fileNameWithoutExtension}</li>`;
    }).join("");
    let currentModel = currentSettings.prompt.replace(/\.[^/.]+$/, "");
    if (!currentModel) {
      currentModel = "Empty";
    }
    const formattedSettings = `<div class="formattedSettings">
    <h2>Prompts</h2>
      <p><b>Current prompt:</b> ${currentModel}</p>
      <ol>${fileListItems}</ol>
    </div>`;
    displayMessage(messageBlock, formattedSettings, currentSettings);
    return;
  }
  if (input.startsWith("/prompt ")) {
    let inputValue = input.substring("/prompt ".length).trim();
    let messageHtml = "";
    if (inputValue.startsWith('"') && inputValue.endsWith('"') || inputValue.startsWith("'") && inputValue.endsWith("'")) {
      inputValue = inputValue.substring(1, inputValue.length - 1);
    }
    if (inputValue === "clear" || inputValue === "c") {
      currentSettings.prompt = "";
      messageHtml = `<div class="formattedSettings"><p><strong>Prompt cleared.</strong></p></div>`;
      displayMessage(messageBlock, messageHtml, currentSettings);
      await plugin.saveSettings();
      return currentSettings;
    }
    const promptAliases = {};
    for (let i = 1; i <= files.length; i++) {
      const fileNameWithoutExtension = files[i - 1].name.replace(/\.[^/.]+$/, "");
      promptAliases[i.toString()] = fileNameWithoutExtension;
    }
    let currentModel;
    if (promptAliases[inputValue]) {
      currentSettings.prompt = promptAliases[inputValue] + ".md";
      currentModel = currentSettings.prompt.replace(/\.[^/.]+$/, "");
      messageHtml = `<div class="formattedSettings"><p><strong>Updated Prompt to ${currentModel}</strong></p></div>`;
    } else if (Object.values(promptAliases).includes(inputValue)) {
      currentSettings.prompt = inputValue + ".md";
      currentModel = currentSettings.prompt.replace(/\.[^/.]+$/, "");
      messageHtml = `<div class="formattedSettings"><p><strong>Updated Prompt to ${currentModel}</strong></p></div>`;
    } else {
      messageHtml = `<div class="formattedSettings"><p><strong>Prompt '${inputValue}' does not exist.</strong></p></div>`;
      new import_obsidian4.Notice("Invalid prompt.");
    }
    displayMessage(messageBlock, messageHtml, currentSettings);
    await plugin.saveSettings();
    return currentSettings;
  }
}
async function commandReference(input, currentSettings, plugin) {
  var _a2;
  const messageBlock = createBotMessage(currentSettings);
  let formattedSettings = "";
  const referenceCurrentNoteElement = document.getElementById("referenceCurrentNote");
  const inputValue = (_a2 = input.split(" ")[1]) == null ? void 0 : _a2.toLowerCase();
  if (inputValue === "true" || inputValue === "on") {
    currentSettings.referenceCurrentNote = true;
    if (referenceCurrentNoteElement) {
      referenceCurrentNoteElement.style.display = "block";
    }
    formattedSettings += `
          <div class="formattedSettings">
            <p><strong>Reference updated: on</strong></p>
          </div>
      `;
  } else if (inputValue === "false" || inputValue === "off") {
    currentSettings.referenceCurrentNote = false;
    if (referenceCurrentNoteElement) {
      referenceCurrentNoteElement.style.display = "none";
    }
    formattedSettings += `
          <div class="formattedSettings">
            <p><strong>Reference updated: off</strong></p>
          </div>
      `;
  } else {
    formattedSettings += `
        <div class="formattedSettings">
          <p><strong>Invalid command.</strong></p>
        </div>
    `;
  }
  displayMessage(messageBlock, formattedSettings, currentSettings);
  await plugin.saveSettings();
}
async function commandTemperature(input, currentSettings, plugin) {
  const messageBlock = createBotMessage(currentSettings);
  const inputValue = input.split(" ")[1];
  const floatValue = parseFloat(inputValue);
  let temperatureSettingMessage;
  if (currentSettings && !isNaN(floatValue) && floatValue >= 0 && floatValue <= 1) {
    currentSettings.temperature = parseFloat((Math.round(floatValue / 0.05) * 0.05).toFixed(2));
    temperatureSettingMessage = `${currentSettings.temperature}`;
  } else {
    temperatureSettingMessage = "Invalid.";
  }
  const formattedSettings = `
      <div class="formattedSettings">
        <p><strong>Temperature updated: ${temperatureSettingMessage}</strong></p>
      </div>
  `;
  displayMessage(messageBlock, formattedSettings, currentSettings);
  await plugin.saveSettings();
}
async function commandMaxTokens(input, currentSettings, plugin) {
  const messageBlock = createBotMessage(currentSettings);
  let formattedSettings = "";
  const maxTokensValue = input.split(" ")[1];
  let maxTokensSettingMessage;
  if (maxTokensValue !== void 0 && maxTokensValue !== "") {
    const inputValue = parseInt(maxTokensValue);
    if (!isNaN(inputValue) && inputValue >= 0) {
      currentSettings.max_tokens = inputValue.toString();
      maxTokensSettingMessage = `Max tokens updated: ${inputValue}`;
    } else {
      maxTokensSettingMessage = "Max tokens update: invalid";
    }
  } else {
    currentSettings.max_tokens = "";
    maxTokensSettingMessage = "Max tokens cleared.";
  }
  formattedSettings += `
      <div class="formattedSettings">
          <p><strong>${maxTokensSettingMessage}</strong></p>
      </div>
  `;
  displayMessage(messageBlock, formattedSettings, currentSettings);
  await plugin.saveSettings();
}
async function commandSystem(input, currentSettings, plugin) {
  const messageBlock = createBotMessage(currentSettings);
  let formattedSettings = "";
  const systemPromptValue = input.match(/"([^"]+)"/);
  if (systemPromptValue !== null) {
    if (systemPromptValue[1]) {
      currentSettings.system_role = systemPromptValue[1];
      formattedSettings += `
              <div class="formattedSettings">
                  <p><strong>System updated: "${systemPromptValue[1]}"</strong></p>
              </div>
          `;
    }
  } else {
    currentSettings.system_role = "";
    formattedSettings += `
          <div class="formattedSettings">
              <p><strong>System cleared.</strong></p>
          </div>
      `;
  }
  displayMessage(messageBlock, formattedSettings, currentSettings);
  await plugin.saveSettings();
}
async function commandAppend(currentSettings) {
  let markdownContent = "";
  const activeFile = app.workspace.getActiveFile();
  if ((activeFile == null ? void 0 : activeFile.extension) === "md") {
    const existingContent = await app.vault.read(activeFile);
    const userNames = document.querySelectorAll(".userName");
    let userNameText = "USER";
    if (userNames.length > 0) {
      const userNameNode = userNames[0];
      Array.from(userNameNode.childNodes).forEach((node) => {
        if (node.nodeType === Node.TEXT_NODE && node.textContent) {
          userNameText = node.textContent.trim().toUpperCase();
        }
      });
    }
    const chatbotNames = document.querySelectorAll(".chatbotName");
    const chatbotNameText = chatbotNames.length > 0 && chatbotNames[0].textContent ? chatbotNames[0].textContent.toUpperCase() : "ASSISTANT";
    if (await this.app.vault.adapter.exists(filenameMessageHistoryJSON)) {
      try {
        const jsonContent = await this.app.vault.adapter.read(filenameMessageHistoryJSON);
        const messages = JSON.parse(jsonContent);
        let skipNext = false;
        markdownContent += messages.filter((message, index, array) => {
          if (skipNext && message.role === "assistant") {
            skipNext = false;
            return false;
          }
          if (message.content.startsWith("/")) {
            skipNext = index + 1 < array.length && array[index + 1].role === "assistant";
            return false;
          }
          return true;
        }).map((message) => {
          let roleText = message.role.toUpperCase();
          roleText = roleText === "USER" ? userNameText : roleText;
          roleText = roleText === "ASSISTANT" ? chatbotNameText : roleText;
          return `###### ${roleText}
${message.content}
`;
        }).join("\n");
      } catch (error) {
        console.error("Error processing message history:", error);
      }
    }
    const updatedContent = existingContent + "\n" + markdownContent;
    await app.vault.modify(activeFile, updatedContent);
    new import_obsidian4.Notice("Appended conversation.");
  } else {
    new import_obsidian4.Notice("No active Markdown file detected.");
  }
}
async function commandSave(currentSettings) {
  let folderName = currentSettings.chatHistoryPath;
  const baseFileName = "Chat History";
  const fileExtension = ".md";
  if (folderName && !folderName.endsWith("/")) {
    folderName += "/";
  }
  const now = new Date();
  const dateTimeStamp = now.getFullYear() + "-" + (now.getMonth() + 1).toString().padStart(2, "0") + "-" + now.getDate().toString().padStart(2, "0") + " " + now.getHours().toString().padStart(2, "0") + "-" + now.getMinutes().toString().padStart(2, "0") + "-" + now.getSeconds().toString().padStart(2, "0");
  try {
    let markdownContent = "";
    const allFiles = app.vault.getFiles();
    const modelNameElement = document.querySelector("#modelName");
    let modelName = "Unknown";
    if (modelNameElement && modelNameElement.textContent) {
      modelName = modelNameElement.textContent.replace("Model: ", "").toLowerCase();
    }
    const templateFile = allFiles.find((file2) => file2.path.toLowerCase() === currentSettings.templateFilePath.toLowerCase());
    if (templateFile) {
      let fileContent = await app.vault.read(templateFile);
      if (/^---\s*[\s\S]*?---/.test(fileContent)) {
        fileContent = fileContent.replace(/^---/, `---
model: ${modelName}`);
      } else {
        fileContent = `---
  model: ${modelName}
---
` + fileContent;
      }
      markdownContent += fileContent;
    } else {
      markdownContent += `---
  model: ${modelName}
---
`;
    }
    const userNames = document.querySelectorAll(".userName");
    let userNameText = "USER";
    if (userNames.length > 0) {
      const userNameNode = userNames[0];
      Array.from(userNameNode.childNodes).forEach((node) => {
        if (node.nodeType === Node.TEXT_NODE && node.textContent) {
          userNameText = node.textContent.trim().toUpperCase();
        }
      });
    }
    const chatbotNames = document.querySelectorAll(".chatbotName");
    const chatbotNameText = chatbotNames.length > 0 && chatbotNames[0].textContent ? chatbotNames[0].textContent.toUpperCase() : "ASSISTANT";
    if (await app.vault.adapter.exists(filenameMessageHistoryJSON)) {
      try {
        const jsonContent = await this.app.vault.adapter.read(filenameMessageHistoryJSON);
        const messages = JSON.parse(jsonContent);
        let skipNext = false;
        markdownContent += messages.filter((message, index, array) => {
          if (skipNext && message.role === "assistant") {
            skipNext = false;
            return false;
          }
          if (message.content.startsWith("/")) {
            skipNext = index + 1 < array.length && array[index + 1].role === "assistant";
            return false;
          }
          return true;
        }).map((message) => {
          let roleText = message.role.toUpperCase();
          roleText = roleText === "USER" ? userNameText : roleText;
          roleText = roleText === "ASSISTANT" ? chatbotNameText : roleText;
          return `###### ${roleText}
${message.content}
`;
        }).join("\n");
      } catch (error) {
        console.error("Error processing message history:", error);
      }
    }
    if (!await app.vault.adapter.exists(folderName)) {
      await app.vault.createFolder(folderName);
    }
    let fileName = "";
    if (currentSettings.allowRenameNoteTitle) {
      let uniqueNameFound = false;
      let modelRenameTitle;
      const fileNameExists = (name) => {
        return allFiles.some((file2) => file2.path === folderName + name + fileExtension);
      };
      while (!uniqueNameFound) {
        modelRenameTitle = await fetchModelRenameTitle(currentSettings, markdownContent);
        if (!fileNameExists(modelRenameTitle)) {
          uniqueNameFound = true;
        }
      }
      fileName = folderName + modelRenameTitle + fileExtension;
    } else {
      fileName = folderName + baseFileName + " " + dateTimeStamp + fileExtension;
    }
    const file = await app.vault.create(fileName, markdownContent);
    if (file) {
      new import_obsidian4.Notice("Saved conversation.");
      app.workspace.openLinkText(fileName, "", true, { active: true });
    }
  } catch (error) {
    console.error("Failed to create note:", error);
  }
}
function commandStop() {
  const controller = getAbortController();
  if (controller) {
    controller.abort();
  }
}
async function removeMessageThread(index) {
  const messageContainer = document.querySelector("#messageContainer");
  const divElements = messageContainer == null ? void 0 : messageContainer.querySelectorAll("div.botMessage, div.userMessage");
  if (divElements && divElements.length > 0 && index >= 0 && index < divElements.length) {
    for (let i = index; i < divElements.length; i++) {
      messageContainer == null ? void 0 : messageContainer.removeChild(divElements[i]);
    }
  }
  messageHistory.splice(index);
  const jsonString = JSON.stringify(messageHistory, null, 4);
  try {
    await app.vault.adapter.write(filenameMessageHistoryJSON, jsonString);
  } catch (error) {
    console.error("Error writing messageHistory.json", error);
  }
}

// src/components/ReferenceCurrentNoteIndicator.ts
async function getActiveFileContent(file) {
  const activeFile = app.workspace.getActiveFile();
  const dotElement = document.querySelector(".dotIndicator");
  let currentNote = "";
  if ((activeFile == null ? void 0 : activeFile.extension) === "md") {
    const content = await app.vault.read(activeFile);
    currentNote = "REFER TO THIS NOTE:```" + content + "```\n";
    if (dotElement) {
      dotElement.style.backgroundColor = "green";
    }
  } else {
    if (dotElement) {
      dotElement.style.backgroundColor = "#da2c2c";
    }
  }
  return currentNote;
}

// src/view.ts
var VIEW_TYPE_CHATBOT = "chatbot-view";
var filenameMessageHistoryJSON = "./.obsidian/plugins/bmo-chatbot/data/messageHistory.json";
var ANTHROPIC_MODELS = ["claude-instant-1.2", "claude-2.0", "claude-2.1"];
var OPENAI_MODELS = ["gpt-3.5-turbo", "gpt-3.5-turbo-1106", "gpt-4", "gpt-4-1106-preview"];
var messageHistory = [];
var lastCursorPosition = {
  line: 0,
  ch: 0
};
var lastCursorPositionFile = null;
var activeEditor = null;
var referenceCurrentNoteContent = "";
var BMOView = class extends import_obsidian5.ItemView {
  constructor(leaf, settings, plugin) {
    super(leaf);
    this.preventEnter = false;
    this.settings = settings;
    this.plugin = plugin;
    this.icon = "bot";
    this.addCursorLogging();
  }
  getViewType() {
    return VIEW_TYPE_CHATBOT;
  }
  getDisplayText() {
    return "BMO Chatbot";
  }
  async onOpen() {
    this.registerEvent(this.app.workspace.on("file-open", this.handleFileOpenEvent.bind(this)));
    const container = this.containerEl.children[1];
    container.empty();
    const chatbotContainer = container.createEl("div", {
      attr: {
        class: "chatbotContainer"
      }
    });
    chatbotContainer.createEl("h1", {
      text: this.settings.chatbotName || DEFAULT_SETTINGS.chatbotName,
      attr: {
        id: "chatbotNameHeading"
      }
    });
    chatbotContainer.createEl("p", {
      text: "Model: " + this.settings.model || DEFAULT_SETTINGS.model,
      attr: {
        id: "modelName"
      }
    });
    const spanElement = chatbotContainer.createEl("span", {
      attr: {
        class: "dotIndicator",
        id: "markDownBoolean"
      }
    });
    const referenceCurrentNoteElement = chatbotContainer.createEl("p", {
      text: "Reference Current Note",
      attr: {
        id: "referenceCurrentNote"
      }
    });
    referenceCurrentNoteElement.appendChild(spanElement);
    referenceCurrentNoteElement.style.display = "none";
    if (referenceCurrentNoteElement) {
      if (this.settings.referenceCurrentNote) {
        referenceCurrentNoteElement.style.display = "block";
      } else {
        referenceCurrentNoteElement.style.display = "none";
      }
    }
    const activeFile = this.app.workspace.getActiveFile();
    if (activeFile) {
      await getActiveFileContent(activeFile);
    }
    const messageContainer = chatbotContainer.createEl("div", {
      attr: {
        id: "messageContainer"
      }
    });
    await loadData();
    messageContainer.id = "messageContainer";
    messageHistory.forEach((messageData) => {
      const buttonContainerDiv = document.createElement("div");
      buttonContainerDiv.className = "button-container";
      if (messageData.role == "user") {
        const userMessageDiv = document.createElement("div");
        userMessageDiv.className = "userMessage";
        userMessageDiv.style.backgroundColor = colorToHex(this.settings.userMessageBackgroundColor || getComputedStyle(document.body).getPropertyValue(DEFAULT_SETTINGS.userMessageBackgroundColor).trim());
        const userMessageToolBarDiv = document.createElement("div");
        userMessageToolBarDiv.className = "userMessageToolBar";
        const userNameSpan = document.createElement("span");
        userNameSpan.className = "userName";
        userNameSpan.textContent = this.settings.userName || DEFAULT_SETTINGS.userName;
        const userP = document.createElement("p");
        const copyUserButton = displayUserCopyButton(userP);
        const trashButton = displayTrashButton();
        userMessageToolBarDiv.appendChild(userNameSpan);
        userMessageToolBarDiv.appendChild(buttonContainerDiv);
        buttonContainerDiv.appendChild(copyUserButton);
        buttonContainerDiv.appendChild(trashButton);
        userMessageDiv.appendChild(userMessageToolBarDiv);
        userMessageDiv.appendChild(userP);
        messageContainer.appendChild(userMessageDiv);
        if (ANTHROPIC_MODELS.includes(this.settings.model)) {
          const fullString = messageData.content;
          const cleanString = fullString.split(" ").slice(1).join(" ").trim();
          userP.innerHTML = marked(cleanString);
        } else {
          userP.innerHTML = marked(messageData.content);
        }
        const messageText = messageData.content;
        const userMessages = messageContainer.querySelectorAll(".userMessage");
        userMessages.forEach((message) => {
          const existingRegenerateButton = message.querySelector(".regenerate-button");
          if (existingRegenerateButton) {
            existingRegenerateButton.remove();
          }
        });
        if (!messageText.startsWith("/")) {
          const lastUserMessage = userMessages[userMessages.length - 1];
          const lastUserMessageToolBarDiv = lastUserMessage.querySelector(".userMessageToolBar");
          const lastButtonContainerDiv = lastUserMessageToolBarDiv == null ? void 0 : lastUserMessageToolBarDiv.querySelector(".button-container");
          const regenerateButton = regenerateUserButton(this.settings, referenceCurrentNoteContent);
          lastButtonContainerDiv == null ? void 0 : lastButtonContainerDiv.insertBefore(regenerateButton, lastButtonContainerDiv.firstChild);
        }
      }
      if (messageData.role == "assistant") {
        const botMessageDiv = document.createElement("div");
        botMessageDiv.className = "botMessage";
        botMessageDiv.style.backgroundColor = colorToHex(this.settings.botMessageBackgroundColor || getComputedStyle(document.body).getPropertyValue(DEFAULT_SETTINGS.botMessageBackgroundColor).trim());
        const botMessageToolBarDiv = document.createElement("div");
        botMessageToolBarDiv.className = "botMessageToolBar";
        const botNameSpan = document.createElement("span");
        botNameSpan.textContent = this.settings.chatbotName || DEFAULT_SETTINGS.chatbotName;
        botNameSpan.className = "chatbotName";
        const messageBlockDiv = document.createElement("div");
        messageBlockDiv.className = "messageBlock";
        let botP = "";
        const messageText = messageData.content;
        if (messageHistory.length >= 2) {
          if (ANTHROPIC_MODELS.includes(this.settings.model)) {
            const cleanString = messageText.split(" ").slice(1).join(" ").trim();
            botP = marked(cleanString);
          } else if (messageData.content.includes('div class="formattedSettings"')) {
            botP = messageData.content;
          } else {
            botP = marked(messageData.content);
          }
        }
        const newBotP = document.createElement("p");
        newBotP.innerHTML = botP;
        botMessageToolBarDiv.appendChild(botNameSpan);
        botMessageToolBarDiv.appendChild(buttonContainerDiv);
        if (!messageText.includes('div class="formattedSettings"')) {
          const copyBotButton = displayBotCopyButton(messageData, this.settings);
          const appendButton = displayAppendButton(messageData);
          buttonContainerDiv.appendChild(copyBotButton);
          buttonContainerDiv.appendChild(appendButton);
        }
        botMessageDiv.appendChild(botMessageToolBarDiv);
        messageBlockDiv.appendChild(newBotP);
        botMessageDiv.appendChild(messageBlockDiv);
        messageContainer.appendChild(botMessageDiv);
        prismHighlighting(messageBlockDiv);
        codeBlockCopyButton(messageBlockDiv);
        if (!messageData.content.includes('div class="formattedSettings"')) {
          addParagraphBreaks(messageBlockDiv);
        }
        const botMessages = messageContainer.querySelectorAll(".botMessage");
        const lastBotMessage = botMessages[botMessages.length - 1];
        lastBotMessage.appendChild(messageBlockDiv);
        lastBotMessage.scrollIntoView({ behavior: "smooth", block: "start" });
      }
    });
    const parentElement = document.getElementById("parentElementId");
    parentElement == null ? void 0 : parentElement.appendChild(messageContainer);
    const chatbox = chatbotContainer.createEl("div", {
      attr: {
        class: "chatbox"
      }
    });
    const textarea = document.createElement("textarea");
    textarea.setAttribute("contenteditable", true.toString());
    textarea.setAttribute("placeholder", "Start typing...");
    chatbox.appendChild(textarea);
    this.textareaElement = textarea;
    this.addEventListeners();
  }
  addEventListeners() {
    this.textareaElement.addEventListener("keyup", this.handleKeyup.bind(this));
    this.textareaElement.addEventListener("keydown", this.handleKeydown.bind(this));
    this.textareaElement.addEventListener("input", this.handleInput.bind(this));
    this.textareaElement.addEventListener("blur", this.handleBlur.bind(this));
  }
  async handleFileOpenEvent(file) {
    await getActiveFileContent(file);
  }
  async handleKeyup(event) {
    const input = this.textareaElement.value.trim();
    const activeFile = this.app.workspace.getActiveFile();
    if (activeFile) {
      if (this.settings.referenceCurrentNote) {
        referenceCurrentNoteContent = await getActiveFileContent(activeFile);
      }
    }
    if (this.settings.allowOllamaStream || !this.settings.ollamaModels.includes(this.settings.model)) {
      if ((input === "/s" || input === "/stop") && event.key === "Enter") {
        this.preventEnter = false;
        executeCommand(input, this.settings, this.plugin);
      }
    }
    if (this.preventEnter === false && !event.shiftKey && event.key === "Enter") {
      loadData();
      event.preventDefault();
      if (input.length === 0) {
        return;
      }
      if (ANTHROPIC_MODELS.includes(this.settings.model)) {
        addMessage("\n\nHuman: " + input, "userMessage", this.settings);
      } else {
        if (!(input === "/s" || input === "/stop")) {
          addMessage(input, "userMessage", this.settings);
        }
      }
      const userP = document.createElement("p");
      const markdownContent = marked(input);
      userP.innerHTML = markdownContent;
      const userMessageDiv = document.createElement("div");
      userMessageDiv.className = "userMessage";
      userMessageDiv.style.backgroundColor = colorToHex(this.settings.userMessageBackgroundColor || getComputedStyle(document.body).getPropertyValue(DEFAULT_SETTINGS.userMessageBackgroundColor).trim());
      const userMessageToolBarDiv = document.createElement("div");
      userMessageToolBarDiv.className = "userMessageToolBar";
      const userNameSpan = document.createElement("span");
      userNameSpan.className = "userName";
      userNameSpan.textContent = this.settings.userName || DEFAULT_SETTINGS.userName;
      const buttonContainerDiv = document.createElement("div");
      buttonContainerDiv.className = "button-container";
      const messageContainer = document.querySelector("#messageContainer");
      if (messageContainer) {
        const userMessages = messageContainer.querySelectorAll(".userMessage");
        userMessages.forEach((message) => {
          const existingRegenerateButton = message.querySelector(".regenerate-button");
          if (existingRegenerateButton) {
            existingRegenerateButton.remove();
          }
        });
        const regenerateButton = regenerateUserButton(this.settings, referenceCurrentNoteContent);
        const copyUserButton = displayUserCopyButton(userP);
        const trashButton = displayTrashButton();
        userMessageToolBarDiv.appendChild(userNameSpan);
        userMessageToolBarDiv.appendChild(buttonContainerDiv);
        if (!input.startsWith("/")) {
          buttonContainerDiv.appendChild(regenerateButton);
        }
        buttonContainerDiv.appendChild(copyUserButton);
        buttonContainerDiv.appendChild(trashButton);
        userMessageDiv.appendChild(userMessageToolBarDiv);
        userMessageDiv.appendChild(userP);
        messageContainer.appendChild(userMessageDiv);
        if (input.startsWith("/")) {
          executeCommand(input, this.settings, this.plugin);
          const modelName = document.querySelector("#modelName");
          if (modelName) {
            modelName.textContent = "Model: " + this.settings.model.toLowerCase();
          }
        } else {
          this.preventEnter = true;
          const botMessageDiv = document.createElement("div");
          botMessageDiv.className = "botMessage";
          botMessageDiv.style.backgroundColor = colorToHex(this.settings.botMessageBackgroundColor || getComputedStyle(document.body).getPropertyValue(DEFAULT_SETTINGS.botMessageBackgroundColor).trim());
          const botMessageToolBarDiv = document.createElement("div");
          botMessageToolBarDiv.className = "botMessageToolBar";
          const botNameSpan = document.createElement("span");
          botNameSpan.textContent = this.settings.chatbotName || DEFAULT_SETTINGS.chatbotName;
          botNameSpan.className = "chatbotName";
          const messageBlockDiv = document.createElement("div");
          messageBlockDiv.className = "messageBlock";
          botMessageToolBarDiv.appendChild(botNameSpan);
          botMessageDiv.appendChild(botMessageToolBarDiv);
          botMessageDiv.appendChild(messageBlockDiv);
          messageContainer.appendChild(botMessageDiv);
          const loadingEl = document.createElement("span");
          loadingEl.setAttribute("id", "loading");
          loadingEl.style.display = "inline-block";
          loadingEl.textContent = "...";
          const updateLoadingAnimation = () => {
            var _a2;
            const loadingEl2 = document.querySelector("#loading");
            if (!loadingEl2) {
              return;
            }
            loadingEl2.textContent += ".";
            if (((_a2 = loadingEl2.textContent) == null ? void 0 : _a2.length) && loadingEl2.textContent.length > 3) {
              loadingEl2.textContent = ".";
            }
          };
          botMessageDiv.appendChild(loadingEl);
          loadingEl.scrollIntoView({ behavior: "smooth", block: "end" });
          const loadingAnimationIntervalId = setInterval(updateLoadingAnimation, 500);
          userMessageDiv.scrollIntoView({ behavior: "smooth", block: "start" });
          this.BMOchatbot(input).then(() => {
            this.preventEnter = false;
            clearInterval(loadingAnimationIntervalId);
          }).catch(() => {
            clearInterval(loadingAnimationIntervalId);
            const botParagraph = document.createElement("p");
            botParagraph.textContent = "Oops, something went wrong. Please try again.";
            botMessageDiv.appendChild(botParagraph);
          });
        }
      }
      this.textareaElement.value = "";
      this.textareaElement.style.height = "29px";
      this.textareaElement.value = this.textareaElement.value.replace(/^[\r\n]+|[\r\n]+$/gm, "");
      this.textareaElement.setSelectionRange(0, 0);
    }
  }
  handleKeydown(event) {
    if (event.key === "Enter" && !event.shiftKey) {
      event.preventDefault();
    }
  }
  handleInput(event) {
    this.textareaElement.style.height = "29px";
    this.textareaElement.style.height = this.textareaElement.scrollHeight + "px";
  }
  handleBlur(event) {
    if (!this.textareaElement.value) {
      this.textareaElement.style.height = "29px";
    }
  }
  exportSettings() {
    return this.settings;
  }
  addCursorLogging() {
    const updateCursorPosition = () => {
      const view = this.app.workspace.getActiveViewOfType(import_obsidian5.MarkdownView);
      if (view) {
        const cursor = view.editor.getCursor();
        lastCursorPositionFile = this.app.workspace.getActiveFile();
        if (cursor != null && this.app.workspace.activeEditor != null) {
          lastCursorPosition = cursor;
          activeEditor = view.editor;
        }
      }
    };
    activeWindow.addEventListener("click", updateCursorPosition);
    activeWindow.addEventListener("keyup", updateCursorPosition);
    activeWindow.addEventListener("keydown", updateCursorPosition);
    activeWindow.addEventListener("input", updateCursorPosition);
  }
  cleanup() {
    this.textareaElement.removeEventListener("keyup", this.handleKeyup.bind(this));
    this.textareaElement.addEventListener("keydown", this.handleKeydown.bind(this));
    this.textareaElement.removeEventListener("input", this.handleInput.bind(this));
    this.textareaElement.removeEventListener("blur", this.handleBlur.bind(this));
    if (this.loadingAnimationIntervalId) {
      clearInterval(this.loadingAnimationIntervalId);
    }
  }
  async BMOchatbot(_input) {
    const activeFile = this.app.workspace.getActiveFile();
    if (activeFile) {
      if (this.settings.referenceCurrentNote) {
        referenceCurrentNoteContent = await getActiveFileContent(activeFile);
      }
    }
    const messageContainerEl = document.querySelector("#messageContainer");
    const chatbotNameHeading = document.querySelector("#chatbotNameHeading");
    const chatbox = document.querySelector(".chatbox textarea");
    if (!this.settings.apiKey && OPENAI_MODELS.includes(this.settings.model)) {
      new import_obsidian5.Notice("API key not found. Please add your OpenAI API key in the plugin settings.");
      if (chatbotNameHeading) {
        chatbotNameHeading.textContent = "ERROR";
      }
      const lastDiv = messageContainerEl == null ? void 0 : messageContainerEl.lastElementChild;
      const errorMessage = document.createElement("p");
      errorMessage.textContent = "API key not found. Please add your OpenAI API key in the plugin settings.";
      errorMessage.classList.add("errorMessage");
      const chatbotNameError = lastDiv.querySelector(".chatbotName");
      chatbotNameError.textContent = "ERROR";
      lastDiv.appendChild(errorMessage);
      chatbox.disabled = true;
    } else {
      if (OPENAI_MODELS.includes(this.settings.model)) {
        try {
          await fetchOpenAIAPI(this.settings, referenceCurrentNoteContent);
        } catch (error) {
          new import_obsidian5.Notice("Error occurred while fetching completion: " + error.message);
          console.log(error.message);
        }
      } else if (this.plugin.settings.openAIBaseModels.includes(this.settings.model)) {
        try {
          await fetchOpenAIBaseAPI(this.settings, referenceCurrentNoteContent);
        } catch (error) {
          new import_obsidian5.Notice("Error occurred while fetching completion: " + error.message);
          console.log(error.message);
        }
      } else if (this.settings.ollamaRestAPIUrl) {
        if (this.settings.allowOllamaStream) {
          await ollamaFetchDataStream(this.settings, referenceCurrentNoteContent);
        } else {
          await ollamaFetchData(this.settings, referenceCurrentNoteContent);
        }
      } else if (ANTHROPIC_MODELS.includes(this.settings.model)) {
        try {
          await requestUrlAnthropicAPI(this.settings, referenceCurrentNoteContent);
        } catch (error) {
          console.error("Error:", error);
        }
      } else if (this.settings.localAIRestAPIUrl) {
        await requestUrlChatCompletion(this.settings, referenceCurrentNoteContent);
      } else {
        new import_obsidian5.Notice("No models detected.");
      }
    }
  }
  async onClose() {
  }
};
async function loadData() {
  if (!await this.app.vault.adapter.exists("./.obsidian/plugins/bmo-chatbot/data/")) {
    this.app.vault.adapter.mkdir("./.obsidian/plugins/bmo-chatbot/data/");
  }
  if (await this.app.vault.adapter.exists(filenameMessageHistoryJSON)) {
    try {
      const fileContent = await this.app.vault.adapter.read(filenameMessageHistoryJSON);
      if (fileContent.trim() === "") {
        messageHistory = [];
      } else {
        messageHistory = JSON.parse(fileContent);
      }
    } catch (error) {
      console.error("Error processing message history:", error);
    }
  } else {
    messageHistory = [];
  }
}

// src/settings.ts
var import_obsidian13 = require("obsidian");

// src/components/settings/GeneralSettings.ts
var import_obsidian7 = require("obsidian");

// src/components/FetchModelList.ts
var import_obsidian6 = require("obsidian");
async function fetchOpenAIBaseModels(plugin) {
  const openai = new openai_default({
    apiKey: plugin.settings.apiKey,
    baseURL: plugin.settings.openAIBaseUrl,
    dangerouslyAllowBrowser: true
    // apiKey is stored within data.json
  });
  const list = await openai.models.list();
  const models = list.data.map((model) => model.id);
  plugin.settings.openAIBaseModels = models;
  return models;
}
async function fetchOllamaModels(plugin) {
  const ollamaRestAPIUrl = plugin.settings.ollamaRestAPIUrl;
  if (!ollamaRestAPIUrl) {
    return;
  }
  try {
    const response = await (0, import_obsidian6.requestUrl)({
      url: ollamaRestAPIUrl + "/api/tags",
      method: "GET",
      headers: {
        "Content-Type": "application/json"
      }
    });
    const jsonData = response.json;
    const models = jsonData.models.map((model) => model.name);
    plugin.settings.ollamaModels = models;
    return models;
  } catch (error) {
    console.error("Error:", error);
  }
}
async function fetchLocalAIModels(plugin) {
  const localAIRestAPIUrl = plugin.settings.localAIRestAPIUrl;
  if (!localAIRestAPIUrl) {
    return;
  }
  const url = localAIRestAPIUrl + "/v1/models";
  try {
    const response = await (0, import_obsidian6.requestUrl)({
      url,
      method: "GET",
      headers: {
        "Content-Type": "application/json"
      }
    });
    const jsonData = response.json;
    const models = jsonData.data.map((model) => model.id);
    plugin.settings.localAIModels = models;
    return models;
  } catch (error) {
    console.error("Error:", error);
  }
}

// src/components/settings/GeneralSettings.ts
function addGeneralSettings(containerEl, plugin, SettingTab7, localAIModels, ollamaModels) {
  containerEl.createEl("h2", { text: "General" });
  new import_obsidian7.Setting(containerEl).setName("API Key").setDesc("Insert API Key from OpenAI or Anthropic.").addText(
    (text) => text.setPlaceholder("insert-api-key").setValue(plugin.settings.apiKey ? `${plugin.settings.apiKey.slice(0, 6)}-...${plugin.settings.apiKey.slice(-4)}` : "").onChange(async (value) => {
      plugin.settings.apiKey = value;
      await plugin.saveSettings();
    }).inputEl.addEventListener("focusout", async () => {
      SettingTab7.display();
    })
  );
  const addOptionsToDropdown = (dropdown, models) => {
    models.forEach((model) => {
      dropdown.addOption(model, model);
    });
  };
  new import_obsidian7.Setting(containerEl).setName("Model").setDesc("Choose a model.").addDropdown(async (dropdown) => {
    plugin.settings.allModels = [];
    if (plugin.settings.apiKey && !plugin.settings.apiKey.startsWith("sk-ant") && plugin.settings.openAIBaseUrl === DEFAULT_SETTINGS.openAIBaseUrl) {
      addOptionsToDropdown(dropdown, OPENAI_MODELS);
      for (const model of OPENAI_MODELS) {
        if (!plugin.settings.allModels.includes(model)) {
          plugin.settings.allModels.push(model);
        }
      }
    }
    if (plugin.settings.apiKey && plugin.settings.apiKey.startsWith("sk-ant")) {
      addOptionsToDropdown(dropdown, ANTHROPIC_MODELS);
      for (const model of ANTHROPIC_MODELS) {
        if (!plugin.settings.allModels.includes(model)) {
          plugin.settings.allModels.push(model);
        }
      }
    }
    if (plugin.settings.ollamaRestAPIUrl && plugin.settings.ollamaModels && plugin.settings.ollamaModels.length > 0) {
      try {
        ollamaModels.forEach((model) => {
          dropdown.addOption(model, model);
          if (!plugin.settings.allModels.includes(model)) {
            plugin.settings.allModels.push(model);
          }
        });
      } catch (error) {
        console.error("Error:", error);
        new import_obsidian7.Notice("Ollama connection error.");
      }
    }
    if (plugin.settings.localAIRestAPIUrl && localAIModels && localAIModels.length > 0) {
      try {
        localAIModels.forEach((model) => {
          dropdown.addOption(model, model);
          if (!plugin.settings.allModels.includes(model)) {
            plugin.settings.allModels.push(model);
          }
        });
      } catch (error) {
        console.error("Error:", error);
        new import_obsidian7.Notice("LocalAI connection error.");
      }
    }
    if (plugin.settings.apiKey && plugin.settings.openAIBaseUrl != DEFAULT_SETTINGS.openAIBaseUrl) {
      const openAIModels = await fetchOpenAIBaseModels(plugin);
      try {
        openAIModels.forEach((model) => {
          dropdown.addOption(model, model);
          if (!plugin.settings.allModels.includes(model)) {
            plugin.settings.allModels.push(model);
          }
        });
      } catch (error) {
        console.error("Error:", error);
        new import_obsidian7.Notice("OpenAI-based url connection error.");
      }
    }
    dropdown.setValue(plugin.settings.model || DEFAULT_SETTINGS.model).onChange(async (value) => {
      plugin.settings.model = value;
      await plugin.saveSettings();
      const modelName = document.querySelector("#modelName");
      if (modelName) {
        modelName.textContent = "Model: " + plugin.settings.model.toLowerCase();
      }
    });
  });
  new import_obsidian7.Setting(containerEl).setName("System").setDesc("System role prompt.").addTextArea(
    (text) => text.setPlaceholder("You are a helpful assistant.").setValue(plugin.settings.system_role !== void 0 ? plugin.settings.system_role : "You are a helpful assistant who responds in markdown.").onChange(async (value) => {
      plugin.settings.system_role = value !== void 0 ? value : DEFAULT_SETTINGS.system_role;
      await plugin.saveSettings();
    })
  );
  new import_obsidian7.Setting(containerEl).setName("Max Tokens").setDesc(descLink("The maximum number of tokens, or words, that the model is allowed to generate in its output.", "https://platform.openai.com/tokenizer")).addText(
    (text) => text.setPlaceholder("4096").setValue(plugin.settings.max_tokens).onChange(async (value) => {
      plugin.settings.max_tokens = value;
      await plugin.saveSettings();
    })
  );
  new import_obsidian7.Setting(containerEl).setName("Temperature").setDesc("Temperature controls how random the generated output is. Lower values make the text more predictable, while higher values make it more creative and unpredictable.").addSlider(
    (slider) => slider.setLimits(0, 1, 0.05).setValue(plugin.settings.temperature !== void 0 ? plugin.settings.temperature : DEFAULT_SETTINGS.temperature).setDynamicTooltip().onChange(async (value) => {
      plugin.settings.temperature = value;
      await plugin.saveSettings();
    })
  );
  new import_obsidian7.Setting(containerEl).setName("Allow Reference Current Note").setDesc("Allow chatbot to reference current active note during conversation.").addToggle(
    (toggle) => toggle.setValue(plugin.settings.referenceCurrentNote).onChange((value) => {
      plugin.settings.referenceCurrentNote = value;
      plugin.saveSettings();
      const referenceCurrentNoteElement = document.getElementById("referenceCurrentNote");
      if (referenceCurrentNoteElement) {
        if (value) {
          referenceCurrentNoteElement.style.display = "block";
        } else {
          referenceCurrentNoteElement.style.display = "none";
        }
      }
    })
  );
  function descLink(text, link) {
    const frag = new DocumentFragment();
    const desc = document.createElement("span");
    desc.innerText = text + " ";
    frag.appendChild(desc);
    const anchor = document.createElement("a");
    anchor.href = link;
    anchor.target = "_blank";
    anchor.rel = "noopener noreferrer";
    anchor.innerText = "(https://platform.openai.com/tokenizer)";
    frag.appendChild(anchor);
    return frag;
  }
}

// src/components/settings/AppearanceSettings.ts
var import_obsidian8 = require("obsidian");
function addAppearanceSettings(containerEl, plugin, SettingTab7) {
  containerEl.createEl("h2", { text: "Appearance" });
  new import_obsidian8.Setting(containerEl).setName("User Name").setDesc("Create a username.").addText(
    (text) => text.setPlaceholder("Enter user name").setValue(plugin.settings.userName || DEFAULT_SETTINGS.userName).onChange(async (value) => {
      plugin.settings.userName = value ? value.toUpperCase() : DEFAULT_SETTINGS.userName;
      text.inputEl.maxLength = 30;
      await plugin.saveSettings();
      const userNames = document.querySelectorAll(".userName");
      userNames.forEach((userName) => {
        userName.textContent = plugin.settings.userName;
      });
    })
  );
  new import_obsidian8.Setting(containerEl).setName("Chatbot Name").setDesc("Name your chatbot.").addText(
    (text) => text.setPlaceholder("Enter chatbot name").setValue(plugin.settings.chatbotName || DEFAULT_SETTINGS.chatbotName).onChange(async (value) => {
      plugin.settings.chatbotName = value ? value.toUpperCase() : DEFAULT_SETTINGS.chatbotName;
      text.inputEl.maxLength = 30;
      await plugin.saveSettings();
      const chatbotNameHeading = document.querySelector("#chatbotNameHeading");
      const chatbotNames = document.querySelectorAll(".chatbotName");
      if (chatbotNameHeading) {
        chatbotNameHeading.textContent = plugin.settings.chatbotName;
      }
      chatbotNames.forEach((chatbotName) => {
        chatbotName.textContent = plugin.settings.chatbotName;
      });
    })
  );
  let colorPicker1;
  const defaultUserMessageBackgroundColor = getComputedStyle(document.body).getPropertyValue(DEFAULT_SETTINGS.userMessageBackgroundColor).trim();
  new import_obsidian8.Setting(containerEl).setName("Background color for User Messages").setDesc("Modify the background color of the userMessage element.").addButton(
    (button) => button.setButtonText("Restore Default").setIcon("rotate-cw").setClass("clickable-icon").onClick(async () => {
      const defaultValue = colorToHex(defaultUserMessageBackgroundColor);
      colorPicker1.setValue(defaultValue);
      const messageContainer = document.querySelector("#messageContainer");
      if (messageContainer) {
        const userMessages = messageContainer.querySelectorAll(".userMessage");
        userMessages.forEach((userMessage) => {
          const element = userMessage;
          element.style.backgroundColor = defaultValue;
        });
        await plugin.saveSettings();
      }
    })
  ).addColorPicker((color) => {
    colorPicker1 = color;
    let defaultValue = plugin.settings.userMessageBackgroundColor;
    if (plugin.settings.userMessageBackgroundColor == "--background-primary") {
      defaultValue = colorToHex(defaultUserMessageBackgroundColor);
    }
    color.setValue(defaultValue).onChange(async (value) => {
      const hexValue = colorToHex(value);
      plugin.settings.userMessageBackgroundColor = hexValue;
      const messageContainer = document.querySelector("#messageContainer");
      if (messageContainer) {
        const userMessages = messageContainer.querySelectorAll(".userMessage");
        userMessages.forEach((userMessage) => {
          const element = userMessage;
          element.style.backgroundColor = hexValue;
        });
      }
      await plugin.saveSettings();
    });
  });
  let colorPicker2;
  const defaultBotMessageBackgroundColor = getComputedStyle(document.body).getPropertyValue(DEFAULT_SETTINGS.botMessageBackgroundColor).trim();
  new import_obsidian8.Setting(containerEl).setName("Background color for Bot Messages").setDesc("Modify the background color of the botMessage element.").addButton(
    (button) => button.setButtonText("Restore Default").setIcon("rotate-cw").setClass("clickable-icon").onClick(async () => {
      const defaultValue = colorToHex(defaultBotMessageBackgroundColor);
      colorPicker2.setValue(defaultValue);
      const messageContainer = document.querySelector("#messageContainer");
      if (messageContainer) {
        const botMessages = messageContainer.querySelectorAll(".botMessage");
        botMessages.forEach((botMessage) => {
          const element = botMessage;
          element.style.backgroundColor = defaultValue;
        });
        await plugin.saveSettings();
      }
    })
  ).addColorPicker((color) => {
    colorPicker2 = color;
    let defaultValue = plugin.settings.botMessageBackgroundColor;
    if (plugin.settings.botMessageBackgroundColor == "--background-secondary") {
      defaultValue = colorToHex(defaultBotMessageBackgroundColor);
    }
    color.setValue(defaultValue).onChange(async (value) => {
      const hexValue = colorToHex(value);
      plugin.settings.botMessageBackgroundColor = hexValue;
      const messageContainer = document.querySelector("#messageContainer");
      if (messageContainer) {
        const botMessages = messageContainer.querySelectorAll(".botMessage");
        botMessages.forEach((botMessage) => {
          const element = botMessage;
          element.style.backgroundColor = hexValue;
        });
      }
      await plugin.saveSettings();
    });
  });
}

// src/components/settings/ChatHistorySettings.ts
var import_obsidian9 = require("obsidian");
function addChatHistorySettings(containerEl, plugin, SettingTab7) {
  containerEl.createEl("h2", { text: "Chat History" });
  new import_obsidian9.Setting(containerEl).setName("Chat History Folder Path").setDesc("Save your chat history in a specified folder.").addText(
    (text) => text.setPlaceholder("BMO/").setValue(plugin.settings.chatHistoryPath || DEFAULT_SETTINGS.chatHistoryPath).onChange(async (value) => {
      plugin.settings.chatHistoryPath = value ? value : DEFAULT_SETTINGS.chatHistoryPath;
      await plugin.saveSettings();
    })
  );
  new import_obsidian9.Setting(containerEl).setName("Template File Path").setDesc("Insert your template file path.").addText(
    (text) => text.setPlaceholder("templates/bmo.md").setValue(plugin.settings.templateFilePath || DEFAULT_SETTINGS.templateFilePath).onChange(async (value) => {
      plugin.settings.templateFilePath = value ? value : DEFAULT_SETTINGS.templateFilePath;
      if (value) {
        if (!plugin.settings.templateFilePath.endsWith(".md")) {
          plugin.settings.templateFilePath += ".md";
        }
        await plugin.saveSettings();
        const allFiles = app.vault.getFiles();
        const fileExists = allFiles.some((file) => file.path.toLowerCase() === plugin.settings.templateFilePath.toLowerCase());
        if (fileExists) {
          text.inputEl.style.borderColor = "";
        } else {
          text.inputEl.style.borderColor = "red";
        }
      } else {
        text.inputEl.style.borderColor = "";
        plugin.settings.templateFilePath = DEFAULT_SETTINGS.templateFilePath;
      }
    })
  );
  new import_obsidian9.Setting(containerEl).setName("Allow Rename Note Title").setDesc("Allow model to rename the note title when saving chat history.").addToggle(
    (toggle) => toggle.setValue(plugin.settings.allowRenameNoteTitle).onChange((value) => {
      plugin.settings.allowRenameNoteTitle = value;
      plugin.saveSettings();
    })
  );
}

// src/components/settings/OllamaSettings.ts
var import_obsidian10 = require("obsidian");

// src/utils/DescriptionLink.ts
function addDescriptionLink(text, link, extraWords, innerText) {
  const frag = new DocumentFragment();
  const desc = document.createElement("span");
  desc.innerText = text + " ";
  frag.appendChild(desc);
  const anchor = document.createElement("a");
  anchor.href = link;
  anchor.target = "_blank";
  anchor.rel = "noopener noreferrer";
  anchor.innerText = innerText;
  frag.appendChild(anchor);
  const extra = document.createElement("span");
  extra.innerText = " " + extraWords;
  frag.appendChild(extra);
  return frag;
}

// src/components/settings/OllamaSettings.ts
function addOllamaSettings(containerEl, plugin, SettingTab7) {
  containerEl.createEl("h2", { text: "Ollama Local LLMs" });
  new import_obsidian10.Setting(containerEl).setName("OLLAMA REST API URL").setDesc(addDescriptionLink("Enter your REST API URL using", "https://ollama.ai/", "", "Ollama")).addText(
    (text) => text.setPlaceholder("http://localhost:11434").setValue(plugin.settings.ollamaRestAPIUrl || DEFAULT_SETTINGS.ollamaRestAPIUrl).onChange(async (value) => {
      plugin.settings.ollamaRestAPIUrl = value ? value : DEFAULT_SETTINGS.ollamaRestAPIUrl;
      await plugin.saveSettings();
    }).inputEl.addEventListener("focusout", async () => {
      SettingTab7.display();
    })
  );
  new import_obsidian10.Setting(containerEl).setName("Allow Stream").setDesc(addDescriptionLink("Allow Ollama models to stream response. Additional setup required: ", "https://github.com/longy2k/obsidian-bmo-chatbot/wiki", "", "[Instructions]")).addToggle(
    (toggle) => toggle.setValue(plugin.settings.allowOllamaStream).onChange((value) => {
      plugin.settings.allowOllamaStream = value;
      plugin.saveSettings();
    })
  );
}

// src/components/settings/AdvancedSettings.ts
var import_obsidian11 = require("obsidian");
function addAdvancedSettings(containerEl, plugin, SettingTab7) {
  containerEl.createEl("h2", { text: "Advanced" });
  new import_obsidian11.Setting(containerEl).setName("OPENAI BASE URL").setDesc("Enter your custom OpenAI base url.").addButton(
    (button) => button.setButtonText("Restore Default").setIcon("rotate-cw").setClass("clickable-icon").onClick(async () => {
      plugin.settings.openAIBaseUrl = DEFAULT_SETTINGS.openAIBaseUrl;
      await plugin.saveSettings();
      SettingTab7.display();
    })
  ).addText(
    (text) => text.setPlaceholder("https://api.openai.com/v1").setValue(plugin.settings.openAIBaseUrl || DEFAULT_SETTINGS.openAIBaseUrl).onChange(async (value) => {
      plugin.settings.openAIBaseUrl = value ? value : DEFAULT_SETTINGS.openAIBaseUrl;
      await plugin.saveSettings();
    }).inputEl.addEventListener("focusout", async () => {
      SettingTab7.display();
    })
  );
  new import_obsidian11.Setting(containerEl).setName("LOCALAI REST API URL").setDesc(addDescriptionLink("Enter your REST API URL using", "https://github.com/go-skynet/LocalAI", "", "LocalAI")).addText(
    (text) => text.setPlaceholder("http://localhost:8080").setValue(plugin.settings.localAIRestAPIUrl || DEFAULT_SETTINGS.localAIRestAPIUrl).onChange(async (value) => {
      plugin.settings.localAIRestAPIUrl = value ? value : DEFAULT_SETTINGS.localAIRestAPIUrl;
      await plugin.saveSettings();
    }).inputEl.addEventListener("focusout", async () => {
      SettingTab7.display();
    })
  );
}

// src/components/settings/PromptSettings.ts
var import_obsidian12 = require("obsidian");
function addPromptSettings(containerEl, plugin, SettingTab7) {
  containerEl.createEl("h2", { text: "Prompts" });
  new import_obsidian12.Setting(containerEl).setName("Prompt Folder Path").setDesc("Reference your prompts from a specified folder.").addText(
    (text) => text.setPlaceholder("BMO/Prompts/").setValue(plugin.settings.promptFolderPath || DEFAULT_SETTINGS.promptFolderPath).onChange(async (value) => {
      plugin.settings.promptFolderPath = value ? value : DEFAULT_SETTINGS.promptFolderPath;
      if (value) {
        let folderPath = plugin.settings.promptFolderPath.trim();
        if (folderPath.endsWith("/")) {
          folderPath = folderPath.substring(0, folderPath.length - 1);
        }
        const folder = app.vault.getAbstractFileByPath(folderPath);
        if (folder && folder instanceof import_obsidian12.TFolder) {
          text.inputEl.style.borderColor = "";
        } else {
          text.inputEl.style.borderColor = "red";
        }
      }
      await plugin.saveSettings();
    }).inputEl.addEventListener("focusout", async () => {
      SettingTab7.display();
    })
  );
  new import_obsidian12.Setting(containerEl).setName("Prompt").setDesc("Select a prompt.").addDropdown((dropdown) => {
    dropdown.addOption("", "");
    dropdown.setValue("");
    if (plugin.settings.promptFolderPath !== "") {
      const files = app.vault.getFiles().filter((file) => file.path.startsWith(plugin.settings.promptFolderPath));
      files.sort((a, b) => a.name.localeCompare(b.name));
      files.forEach((file) => {
        const fileName = file.name.replace(/\.[^/.]+$/, "");
        dropdown.addOption(file.name, fileName);
      });
    }
    dropdown.setValue(plugin.settings.prompt || DEFAULT_SETTINGS.prompt).onChange(async (value) => {
      plugin.settings.prompt = value ? value : DEFAULT_SETTINGS.prompt;
      await plugin.saveSettings();
    });
  });
}

// src/settings.ts
var BMOSettingTab = class extends import_obsidian13.PluginSettingTab {
  constructor(app2, plugin) {
    super(app2, plugin);
    this.plugin = plugin;
  }
  async display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h1", { text: "BMO Chatbot Settings" });
    const changeLogLink = containerEl.createEl("a", {
      text: "Changelog",
      href: "https://github.com/longy2k/obsidian-bmo-chatbot/releases"
    });
    changeLogLink.style.fontSize = "0.8rem";
    containerEl.createEl("p", { text: "Type `/help` in chat for commands." });
    const localAIModels = await fetchLocalAIModels(this.plugin);
    const ollamaModels = await fetchOllamaModels(this.plugin);
    addGeneralSettings(this.containerEl, this.plugin, this, localAIModels, ollamaModels);
    addAppearanceSettings(this.containerEl, this.plugin, this);
    addChatHistorySettings(this.containerEl, this.plugin, this);
    addPromptSettings(this.containerEl, this.plugin, this);
    addOllamaSettings(this.containerEl, this.plugin, this);
    addAdvancedSettings(this.containerEl, this.plugin, this);
  }
};

// src/components/EditorCommands.ts
var import_obsidian14 = require("obsidian");
async function renameTitleCommand(BMOSettings4) {
  var _a2, _b, _c;
  let uniqueNameFound = false;
  let modelRenameTitle;
  let folderName = ((_c = (_b = app.vault.getAbstractFileByPath(((_a2 = app.workspace.getActiveFile()) == null ? void 0 : _a2.path) || "")) == null ? void 0 : _b.parent) == null ? void 0 : _c.path) || "";
  const fileExtension = ".md";
  const allFiles = app.vault.getFiles();
  const activeFile = app.workspace.getActiveFile();
  let fileContent = "";
  try {
    if (activeFile) {
      fileContent = await app.vault.read(activeFile);
    }
    if (folderName && !folderName.endsWith("/")) {
      folderName += "/";
    }
    const fileNameExists = (name) => {
      return allFiles.some((file) => file.path === folderName + name + fileExtension);
    };
    while (!uniqueNameFound) {
      modelRenameTitle = await fetchModelRenameTitle(BMOSettings4, fileContent);
      if (!fileNameExists(modelRenameTitle)) {
        uniqueNameFound = true;
      }
    }
    const fileName = folderName + modelRenameTitle + fileExtension;
    if (activeFile) {
      app.vault.rename(activeFile, fileName);
    }
    new import_obsidian14.Notice("Renamed note title.");
  } catch (error) {
    console.error(error);
  }
}
async function promptSelectGenerateCommand(BMOSettings4) {
  const view = this.app.workspace.getActiveViewOfType(import_obsidian14.MarkdownView);
  const select = view.editor.getSelection();
  if (view && select && select.trim() !== "") {
    if (OPENAI_MODELS.includes(BMOSettings4.model)) {
      try {
        const response = await fetchOpenAIAPIEditor(BMOSettings4, select);
        const cursorStart = view.editor.getCursor("from");
        view.editor.replaceSelection(response);
        const cursorEnd = {
          line: cursorStart.line,
          ch: cursorStart.ch + (response == null ? void 0 : response.length)
        };
        view.editor.setSelection(cursorStart, cursorEnd);
      } catch (error) {
        new import_obsidian14.Notice("Error occurred while fetching completion: " + error.message);
        console.log(error.message);
      }
    } else if (BMOSettings4.openAIBaseModels.includes(BMOSettings4.model)) {
      try {
        const response = await fetchOpenAIBaseAPIEditor(BMOSettings4, select);
        const cursorStart = view.editor.getCursor("from");
        view.editor.replaceSelection(response);
        const cursorEnd = {
          line: cursorStart.line,
          ch: cursorStart.ch + (response == null ? void 0 : response.length)
        };
        view.editor.setSelection(cursorStart, cursorEnd);
      } catch (error) {
        new import_obsidian14.Notice("Error occurred while fetching completion: " + error.message);
        console.log(error.message);
      }
    } else if (BMOSettings4.ollamaRestAPIUrl) {
      try {
        const response = await ollamaFetchDataEditor(BMOSettings4, select);
        const cursorStart = view.editor.getCursor("from");
        view.editor.replaceSelection(response);
        const cursorEnd = {
          line: cursorStart.line,
          ch: cursorStart.ch + (response == null ? void 0 : response.length)
        };
        view.editor.setSelection(cursorStart, cursorEnd);
      } catch (error) {
        new import_obsidian14.Notice("Error occurred while fetching completion: " + error.message);
        console.log(error.message);
      }
    } else if (ANTHROPIC_MODELS.includes(BMOSettings4.model)) {
      try {
        const response = await requestUrlAnthropicAPIEditor(BMOSettings4, select);
        view.editor.replaceSelection(response);
      } catch (error) {
        new import_obsidian14.Notice("Error occurred while fetching completion: " + error.message);
        console.log(error.message);
      }
    } else if (BMOSettings4.localAIRestAPIUrl) {
      try {
        const response = await ollamaFetchDataEditor(BMOSettings4, select);
        const cursorStart = view.editor.getCursor("from");
        view.editor.replaceSelection(response);
        const cursorEnd = {
          line: cursorStart.line,
          ch: cursorStart.ch + (response == null ? void 0 : response.length)
        };
        view.editor.setSelection(cursorStart, cursorEnd);
      } catch (error) {
        new import_obsidian14.Notice("Error occurred while fetching completion: " + error.message);
        console.log(error.message);
      }
    }
    new import_obsidian14.Notice("Generation complete.");
  } else {
    new import_obsidian14.Notice("No text selected.");
  }
}

// src/main.ts
var DEFAULT_SETTINGS = {
  apiKey: "",
  max_tokens: "",
  model: "",
  system_role: "",
  temperature: 1,
  userName: "USER",
  chatbotName: "BMO",
  chatbotContainerBackgroundColor: "--background-secondary",
  userMessageBackgroundColor: "--background-primary",
  botMessageBackgroundColor: "--background-secondary",
  chatHistoryPath: "BMO/",
  templateFilePath: "",
  promptFolderPath: "",
  prompt: "",
  openAIBaseUrl: "https://api.openai.com/v1",
  ollamaRestAPIUrl: "http://localhost:11434",
  allowOllamaStream: false,
  localAIRestAPIUrl: "",
  referenceCurrentNote: false,
  allowRenameNoteTitle: false,
  allModels: [],
  ollamaModels: [],
  localAIModels: [],
  openAIBaseModels: []
};
var checkActiveFile = null;
var BMOGPT7 = class extends import_obsidian15.Plugin {
  async onload() {
    await this.loadSettings();
    this.registerEvent(
      this.app.workspace.on("active-leaf-change", () => {
        this.handleFileSwitch();
      })
    );
    this.registerView(
      VIEW_TYPE_CHATBOT,
      (leaf) => new BMOView(leaf, this.settings, this)
    );
    this.addRibbonIcon("bot", "BMO Chatbot", () => {
      this.activateView();
    });
    this.addCommand({
      id: "open-bmo-chatbot",
      name: "Open BMO Chatbot",
      callback: () => {
        this.activateView();
      },
      hotkeys: [
        {
          modifiers: ["Mod"],
          key: "0"
        }
      ]
    });
    this.addCommand({
      id: "rename-note-title",
      name: "Rename Note Title",
      callback: () => {
        renameTitleCommand(this.settings);
      },
      hotkeys: [
        {
          modifiers: ["Mod"],
          key: "'"
        }
      ]
    });
    this.registerEvent(
      this.app.workspace.on("file-menu", (menu, file) => {
        if (!(file instanceof import_obsidian15.TFile)) {
          return;
        }
        menu.addItem((item) => {
          item.setTitle("BMO Chatbot: Generate new title").onClick(() => renameTitleCommand(this.settings));
        });
      })
    );
    this.addCommand({
      id: "prompt-select-generate",
      name: "Prompt Select Generate",
      callback: () => {
        promptSelectGenerateCommand(this.settings);
      },
      hotkeys: [
        {
          modifiers: ["Mod"],
          key: "="
        }
      ]
    });
    this.addSettingTab(new BMOSettingTab(this.app, this));
  }
  handleFileSwitch() {
    checkActiveFile = this.app.workspace.getActiveFile();
  }
  async onunload() {
    this.app.workspace.getLeavesOfType(VIEW_TYPE_CHATBOT).forEach((leaf) => {
      const bmoView = leaf.view;
      if (bmoView) {
        this.saveSettings();
        bmoView.cleanup();
      }
    });
  }
  async activateView() {
    this.app.workspace.detachLeavesOfType(VIEW_TYPE_CHATBOT);
    const rightLeaf = this.app.workspace.getRightLeaf(false);
    await rightLeaf.setViewState({
      type: VIEW_TYPE_CHATBOT,
      active: true
    });
    this.app.workspace.revealLeaf(
      this.app.workspace.getLeavesOfType(VIEW_TYPE_CHATBOT)[0]
    );
    const textarea = document.querySelector(".chatbox textarea");
    if (textarea) {
      textarea.style.opacity = "0";
      textarea.style.transition = "opacity 1s ease-in-out";
      setTimeout(() => {
        textarea.focus();
        textarea.style.opacity = "1";
      }, 50);
    }
    this.app.workspace.revealLeaf(
      this.app.workspace.getLeavesOfType(VIEW_TYPE_CHATBOT)[0]
    );
    const messageContainer = document.querySelector("#messageContainer");
    if (messageContainer) {
      messageContainer.scroll({
        top: messageContainer.scrollHeight,
        behavior: "smooth"
      });
    }
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
};
